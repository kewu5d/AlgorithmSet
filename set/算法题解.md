# 算法题解

# 蓝桥杯真题--蓝桥云课

1. [拼正方形](https://www.lanqiao.cn/problems/19696/learning/?page=1&first_category_id=1&second_category_id=3&tags=省赛,2024&tag_relation=intersection&asc=1)

    分析：

    - ==利用体积S求边长a==

    **思路1：**

    - 先计算手头上现有的方块总面积S
    - 假设一个最低边长a值
    - 循环a++，当a*a **<font color=red>>=</font>** S，跳出循环（面积刚好够，但凑不出正方形）
    - 输出a-1（原值a，方块S不够）

    隐患点：a*a  正好=S，且正好可以拼成

    - 一般题目设计的数字还是特定的，不会乱来

    **思路2：纯数学**-----疑惑

    - 理论最大边长a：$\sqrt{73851378887217385137888721*4+10470245}$
        - ==win+r+calc==调出计算器
    - 判断是否可行：a为奇数，则正方形因半周包裹1*1方块
        - 即a+a-1 = 10470245
            - 而a-1+a-1+1 = 1047
        - 输出a
    - 否则输出a-1

2. [4.劲舞团 - 蓝桥云课](https://www.lanqiao.cn/problems/19697/learning/?page=1&first_category_id=1&second_category_id=3&tags=省赛,2024&tag_relation=intersection&asc=1)

    分析：

    - 此题目中的log.txt文件会作为读入
    - ==时间戳==：该点击下的当时时间，时间间隔即为两时间戳相减

    思路：

    - 搞个结构体保存下三变量，用于读入txt文件
    - 条件：时间戳之差<=1000ms(1s) && 字符键位按对了，K++
        - 连续符合，K++，断了
            - 答对了记录此次K后，K=1
            - 答错了，K=0（重新）
    - 最后输入max（K）

3. [5.报数游戏 - 蓝桥云课](https://www.lanqiao.cn/problems/19698/learning/?page=1&first_category_id=1&second_category_id=3&tags=省赛,2024&tag_relation=intersection&asc=1)

    分析：循环超时

    ```cpp
    //最小公倍数120，240.。。 -----这里压根不用考虑！！！！！！！！！11111
    
    int main()
    {
    	ll cnt = 0;//奇数i， 偶数j 
    	ll j = 0;
    	while(1) 
    	{
    		j+= 24;
    		cnt += 2;
    		if (cnt == 202420242024)break;//偶数 
    	}
    	cout << j << endl;
    	return 0;
    }
    ```

    **关键问题**：

    - 目标值 `202420242024` 是一个极大的数（约 2万亿亿），而每次循环 `cnt` 仅增加 2。程序需要执行约 *1e12* 次循环，远超计算机的实际处理能力（现代 CPU 每秒约处理 1e9 次操作，需约 1e3 秒，即 16分钟，但实际上内存和指令限制会大幅延长）。

    总结:

    - 原代码因计算规模过大而看似“死循环”，**<font color=red>实际需用数学方法直接求解</font>**。通过分析碰撞规律和等效计数，可快速得出结果

4. [7.召唤数学精灵 - 蓝桥云课](https://www.lanqiao.cn/problems/19700/learning/?page=1&first_category_id=1&second_category_id=3&tags=2024,省赛&tag_relation=intersection)

    分析：一看数就知道暴力枚举不了，通过找规律

    思路：

    - 先用**计算机程序**枚举前1000的精灵数字i看看
    - 可以发现除特殊的1，3外！！！
    - **每两百**个数中就有**4个**精灵数字
        - 2024041331404202/200 * 4     +2！！！
    - 计算输出答案

    补充：

    - *B*(*n*)=1×2×⋯×*n*=*n*!
    - ∀n≥10,B(n)≡0(mod100)∀*n*≥10,*B*(*n*)≡0(mod100)
        - 因为n>=10中，包含2 * 5 * 10，所以mod100，恒等于0

5. [9.数字串个数 - 蓝桥云课](https://www.lanqiao.cn/problems/19702/learning/?page=1&first_category_id=1&second_category_id=3&tags=2024,省赛&tag_relation=intersection)

    分析：==快速幂+容斥原理==<img src="D:\Node-typora\note-picture\e687b58ff932ba1d2a379ae06653a6e5_720.png" alt="e687b58ff932ba1d2a379ae06653a6e5_720" style="zoom:33%;" />

    思路：如图

    - 定义取模数：

        ```cpp
        #define ll long long
        ll mod = 1e9 +7;//表示10^9 +7
        ```

6. [19.小球反弹 - 蓝桥云课](https://www.lanqiao.cn/problems/19732/learning/?page=2&first_category_id=1&second_category_id=3&tags=2024,省赛&tag_relation=intersection)

    分析：

    - 碰到墙角会**原路返回**，原路回到左上角顶点（起点）
    - 答案 =<font color=red> 运动路程（无论啥样） * 2</font>
    - ==路程x，y = 速度dx、dy * **时间t**==

    思路：

    - 利用这一特点,找到小球下一次碰到墙角时候,计算此时的路程,因为此时小球就要原路返回了,所以最终结果就是此路程乘以2
    - ![image-20250323110347929](D:\Node-typora\note-picture\image-20250323110347929.png)
    - 如上图所示，x、y是可以整除长和宽的，也就是取余==0

    代码：

7. [11.食堂 - 蓝桥云课](https://www.lanqiao.cn/problems/19724/learning/?page=2&first_category_id=1&second_category_id=3&tags=2024,省赛&tag_relation=intersection)

    分析：先处理b6，再处理b4，**b6放a2就变成了b4**

    - 即处理大问题，大转小，处理小问题

    思路代码：

    - ```cpp
        #include <iostream>
        using namespace std;
        #define ll long long
        int a2, a3, a4, b4, b6, q;
        int ans = 0;
        int main()
        {
            cin >> q;
            while (q--) {
                cin >> a2 >> a3 >> a4 >> b4 >> b6;
                ans = 0;
                while (a3 >= 2 && b6) {
                    ans += 6;
                    a3 -= 2;
                    b6--;
                }//a3 = 0,1
                while (a2 && b6) {
                    ans += 2;
                    a2--;
                    b6--;
                    b4++;
                }//a2没了
                while (a4 && b6) {
                    ans += 4;
                    a4--;
                    b6--;
                }//a4没了，a2已经没了，b6就放不了别的数了，b6--
                while (a3 && b6) {
                    ans += 3;
                    a3--;
                    b6--;
                }//用可能剩下的a3装b6
                
        
        
                //b6没了，处理b4
                while (a4 && b4) {
                    ans += 4;
                    a4--;
                    b4--;
                }
                while (a2 >= 2 && b4) {
                    ans += 4;
                    a2 -= 2;
                    b4--;
                }//a2=0，1
                while (a3 && b4) {
                    ans += 3;
                    a3--;
                    b4--;
                }
                while (a2 && b4) {
                    ans += 2;
                    a2--;
                    b4--;
                }
                cout << ans << endl;
            }
            return 0;
        }
        ```

8. [1.赢球票 - 蓝桥云课](https://www.lanqiao.cn/problems/94/learning/?page=1&first_category_id=1&second_category_id=3&tags=暴力,模拟&tag_relation=union)

    分析：注意审题

    - 求收取卡片的数字之和 
    - <font color=red>随便你从哪里开始数，求最多 </font>
        - 所以就不要想着用循环单链表，让指针指来指去

    思路：

    - 整个标记数组，循环n轮，<font color=red>依次以1~n为起点数数</font>，**每轮结束后，初始化标记数组**
    - 对每一轮得到的ans，**取max**
    - 进行**取余**实现循环操作

    犯错：

    - 临时变量num写错成n

    - 新一轮开始cnt没有初始化为1

    - 当flag[s] == 1时，直接跳过这个被已经拿走了，数下一个，cnt不变 

        - ```cpp
            s = ++s % n ;
            //cnt++;
            ```
    
    代码：
    
    - ```cpp
        #include <bits/stdc++.h>
        using namespace std;
        
        int n, card[105];
        int vis[105];//是否数过 
        int main()
        {
        	cin >> n;
        	int maxcard = 0; 
        	for (int i=0; i<n; i++){
        		cin >>card[i];
        		maxcard = max(maxcard, card[i]);
        	}
        	
        	int maxans = 0;
        	for (int i=0; i<n; i++)
        	{
        		int pos = i;//枚举开始数的card位置
        		memset(vis, 0, sizeof(vis)) ;
        		int cnt = 1;//数数
        		int num = n;//总牌数
        		int ans = 0;
        		//两种情况跳出循环：1.全部数完，2.数到的数字大于最大牌面数 
        		while (num>0)
        		{
        			if (card[pos] == cnt && vis[pos] ==0)
        			{
        				//ans++;
        				ans += card[pos];
        				vis[pos] = 1;
        				cnt = 1;//下一个重新数 
        				num--;
        				pos = (pos+1)%n;
        			}
        			else if (vis[pos]== 1)
        			{
        				pos = (pos+1)%n;
        			}
        			else {//没拿过但是不等于cnt 
        				cnt++;
        				if (cnt > maxcard)break;
        				pos = (pos+1)%n;
        			}
        		}
        		maxans = max(maxans, ans);
        	}
        	cout << maxans << endl;
        	return 0;
        }
        ```
    
    - 



## 暴力枚举

1. [1.训练士兵 - 蓝桥云课](https://www.lanqiao.cn/problems/19703/learning/?page=2&first_category_id=1&second_category_id=3&status=2)

    分析：

    - 利用贪心。所有士兵都进行一次训练，是**单训划算**还是**集训划算**

    思路：

    - sum：所有**还没达到顶级**的士兵**全部都单训**达到顶级的费用
    - allone：所有**还没达到顶级**的士兵**单训一次**的费用
    - cnt[i]：训练达到`i`后，有士兵达到了顶级，训`i`次达顶级的**士兵数的单训花销**。
        - 下一次第i+1次训练，这些士兵不参与训练
        - 需要减去的单训费用，即`allone - cnt[i]`
    - ans：集训的总花销
    - 最小花销：集训花销，加单独训练总花销， 即ans + sum

    代码：

    - ```cpp
        #include <iostream>
        #include <limits.h>
        #define ll long long
        using namespace std;
        const ll N = 1e6+5;
        ll n, p[N], c[N], s;
        ll allone, sum, cnt[N];//分别表示：全单训一次、全部单训、需要训练N次的士兵花销 
        int main()
        {
            cin>> n >> s;
            ll maxcnt = 0;//士兵中最多训练次数 
            for (int i=1;i<=n;i++)
            {
                cin >> p[i] >> c[i];//第i名，单独训练，所需次数 
                if(maxcnt < c[i]) maxcnt = c[i];
                sum += p[i]*c[i];//全部单训达顶级
                allone += p[i];//全部单训一次
                cnt[c[i]] += p[i];//********
            }
            //枚举+贪心：每一次全训一次是单训好还是集训好
            ll ans = 0;
            for (int i=1;i <=maxcnt; i++)
            {
                if (allone <= s){//以后直接单训得了
                    cout << sum+ans << endl;return 0;
                }
                //集训
                sum -= allone;//省下一笔全部单训的钱
                ans += s;//集训花销
                
                //更新未达级的士兵全部单训一次的花销
                allone -= cnt[i];//训i次的士兵，此时已经达到顶级了，后续不用再跟训了
                                //所以这里减去的是已经达满级，后续还要继续训练的单训费用
            }
            cout << sum + ans << endl;
            return 0;
        }
        ```

2. 




## 前缀和&差分

`a[i] =+ a[i-1]` :前缀和写法，原数组作为前缀和数组------即**自前缀**

1. [P1115 最大子段和 - 洛谷](https://www.luogu.com.cn/problem/P1115)

    分析：

    - 暴力枚举，前缀和的一维区间和，思维

    思路1：

    - 利用前缀和区间公式：<font color=red>sum[r] - sum[l-1] = [l, r]的和</font>
    - 题目要求最大字段和，即让sum[r]最大，让sum[l-1]最小
        - sum[r]：前缀和的后缀/面值（前缀和）最大
        - sum[l-1]：前缀和的前缀/面值（前缀和）最小
    - 定义：
        - suf[i]：前缀和的**后缀最大值**----<u>前缀和数组的后缀元素还是前缀和</u>
        - pre[i]：前缀和的前缀最小值
    - 构建：类似与前缀和的构建方式（suma[i] = suma[i-1] + a[i]）
        - suf：**从后往前**。==suf[i] = max(suf[i + 1], suma[i])==
        - pre：pre[i] = min(pre[i - 1], suma[i])
    - 答案即对suf[i] - pre[i-1]取max

    代码：

    - ```cpp
        #include <bits/stdc++.h>
        #define ll long long
        using namespace std;
        const int N = 2e5 +5;
        ll a[N], suf[N], pre[N];
        int main()
        {
        	int n;cin >> n;
        	for (int i=1;i<=n; i++)
        	{
        		cin >> a[i];a[i] +=a[i-1];
        	}
        	//含i的区间和最大，即sum(r) - sum(l-1)最大
        	//即i右边所有最大sum值，i左边最小sum值
        	//前缀和的后缀最值 ，--------------------------类似求前缀和的求法
        	
        	//pre[0] = INT_MAX;如果这里为了接下来的比较初始化为尽可能大值，在输出时，按照实例常识就要赋值回0 
        	suf[n+1] = -1e18;
        	for (int i=1; i<=n; i++)
        	{
        		pre[i] = min(pre[i-1], a[i]);//前缀和的前缀最小（前缀和）值 
        	//	suf[i] = max(suf[i+1], a[i]);//前缀和的后缀最大（前缀和）值 
        	}
        	for (int i=n;i>0; i--)//从后往前 ----------------`!!!
        	{
        		suf[i] = max(suf[i+1], a[i]);
        	}
        	//pre[0] = 0;//实际意义 
        	for (int i=1; i<=n; i++) 
        	{
        		cout << suf[i]-pre[i-1] << ' ';//含i的最大区间和
        	}
            //将以上改为对ans = max(ans, suf[i]-pre[i-1])，既是本题答案
        	cout << endl;return 0;
        }
        ```

    思路2：思维
    
    - 第一个元素作为一个区间，称之原区间
    - 原区间+下一个元素
        - 如果`原区间+下一个元素`  >= `下一个元素` ，说明可以将其作为新区间
        - 如果小于< `下一个元素`，就让`下一个元素`单独作为新区间就好了
            - <font color =red>因为对于这个元素而言，加上前面这些还让自身退步了，所以放弃那些拖油瓶自己立门派</font>
            - 代码：new = max(lase_new + e,   e)
    - 记得每次更新新区间后，与答案取max，最后输出最大字段和
    
    代码：
    
    - ```cpp
        #include <iostream>
        using namespace std;
        const int N = 2e5+5; 
        int a[N] , temp[N];//这里的a，temp数组都可以改用变量，来进行空间优化 
        int main()
        {
        	int n;cin >> n;
        	int ans= -1e8;
        	for (int i=1;i<=n; i++)
        	{
        		cin >> a[i];
        		if (i == 1)temp[i] = a[i];//可能的最大字段和
        		else
        		{
        			temp[i] = max(temp[i-1]+a[i], a[i]);//原区间加上新元素后比新元素还小，就让新元素成一个新区间 
        			ans = max (ans, temp[i]);
        		 } 
        	}
        	cout << ans << endl;return 0;
        }
        ```
    
    思路3：
    
    - 与思路2原理一样，采用dp动态规划的方式实现
    
    代码：
    
    - ```cpp
        #include <iostream>
        #include <algorithm>
        #define ll long long
        using namespace std;
        const int N = 2e5+10;
        ll dp[N], a[N];//dp[i]：表示以a[i]结尾的最大字段和 
        int main()
        {
        	int n; cin >> n;
        	for (int i=1; i<=n;i++)cin >> a[i];
        	dp[0] = -1e18;
        	ll ans = -1e18;
        	for (int i=1; i<=n; i++)
        	{
        		if (dp[i-1] + a[i] > a[i])
        		{//上升了,接在以a[i-1]结尾的字段和上
        			dp[i] = dp[i-1]+a[i];
        		}
        		else dp[i] = a[i];
        		
        		ans = max(ans, dp[i]);
        	}
        	cout << ans << endl;
        	return 0;
        }
        ```
    
    - 
    
2. 



## 滑动窗口&双指针

1. [1.日志统计 - 蓝桥云课](https://www.lanqiao.cn/problems/179/learning/?page=1&first_category_id=1&second_category_id=3&tags=双指针&tag_relation=union)

    分析：输入的N行日志无顺序，进行预处理

    - 先按id排序，**再按时间ts排序**
    - <font color=red>以**时间[ts, ts+D)为滑动窗口**（判断条件），在这个时间段中就点赞数++，不在说明不连续点赞数--</font>

    思路：

    - 记录该idlike[ ]的编号的点赞数
    - 判断函数ishot( idlike[ ] >= k)，这个函数是否为热点，是就返回true，输出
        - （因为以id为下标输出，保证按从小到大的顺序输出热帖id）
    - 定义l，r。满足滑动窗口的基本模板
        - 时间作为判断条件，缩小左边框，直至合法（回到合法时间）

    代码：

    - ```cpp
        #include<cstdio>
        #include<algorithm>
        using namespace std;
        int n, d, k;
        int nowlike[100005];//此id的连续点赞数
        struct node {
            int ts;
            int id;
        };
        node arr[100005];
        bool ishot[100005];//???????????????
        bool cmp(node x, node y)
        {
            return x.ts < y.ts;//只按时间升序排列
        }
        int main()
        {
            scanf_s("%d%d%d", &n, &d, &k);
            for (int i = 1; i <= n; i++)
                scanf_s("%d%d", &arr[i].ts, &arr[i].id);
            sort(arr + 1, arr + 1 + n, cmp);
            int l = 1;
            for (int i = 1; i <= n; i++)    //这里i就是r右指针（窗口）
            {
                nowlike[arr[i].id]++;   //各id的所欲点赞数都记录下
                //--------------------------------以时间[ts,ts+d)为滑动窗口！！！！！！
                while (arr[i].ts >= arr[l].ts + d) nowlike[arr[l++].id]--;//不合法不连续。缩小l++，点赞数-1
        
                if (nowlike[arr[i].id] >= k) ishot[arr[i].id] = true;
                //这里单独另弄一个ishot数组是为了及时记录该热点id。！！！！！！因为随着滑动，连续点赞数会发生改变！！！！！
            }
            //暴力枚举整个区间，来判断所有id编号
            for (int i = 0; i <= 100005; i++)
                if (ishot[i])
                    printf("%d\n", i);
            return 0;
        }
        ```
        
    - 问题代码

        - ```cpp
            #include <iostream>
            #include <map>
            #include <algorithm>
            using namespace std;
            const int N = 1e5+5;
            pair<int, int> p[N];//
            int id[N];
            bool cmp(pair<int , int> a, pair<int, int> b)
            {
                if (a.second != b.second)     return a.second < b.second;// 升序
                else    return a.first < b.first;
            }
            int main()
            { 
                    int n, d, k;cin >> n >> d >> k;//d为时间差 
                    for (int i=1; i<= n; i++)
                    {
                        cin >> p[i].first >> p[i].second;
                    }
                    sort(p+1, p+n+1, cmp);// 1~n
                    int l=1, r = 1;
                    int temp = 0;
                    while(r <= n)	//右边框为n 
                    {	
                       if (p[r].second == p[l].second && p[r].first-d < p[l].first)
                       {//此id合法 
                       		temp++;//加完就可以判断 
            				if (temp >= k)
            				{
            					cout << p[l].second << endl;
            					temp = 0;
            					while (p[r].second == p[l].second && r<n)r++;
            					l = r;//移过来尺取下一个id的点赞数 
            					continue;
            				}
            		   }
            		   else if (p[r].second != p[l].second) 
            		   {
            		   		l = r;//移过来尺取下一个id的点赞数 
            		   		continue;
            		   }
            		   while(p[r].first-d >= p[l].first && l<r) 
            		   {//时间间隔过长，缩小 
            		   		temp--;
            				l++; 
            		   }
            		  // if (p[r].first-d < p[l].first)continue;
            		   r++;
                    }
                return 0; 
            }
            ```

2. [1.合并数列 - 蓝桥云课](https://www.lanqiao.cn/problems/17106/learning/?page=1&first_category_id=1&second_category_id=3&name=合并数)

    分析：数组中各数之和相等
    
    思路：
    
    - 利用了前缀和的思想
    - 当前的前缀和不相同时，较小数组需要向右合并一个元素，合并操作ans++
    - 因为保证了两数组和是相等的，所以通过数组元素必要的合并，两数组会相同
    
    代码：
    
    - ```cpp
        #include <iostream>
        using namespace std;
        const int N = 1e5 + 5;
        int a[N], b[N];
        int n, m;
        int main()
        {
            int ans = 0;//操作次数
            cin >> n >> m;
            for (int i = 1; i <= n; i++) cin >> a[i];
            for (int i = 1; i <= m; i++) cin >> b[i];
            int u = 0, v = 0;//下标
            int cnta = 0, cntb = 0;
            while (u <= n && v <= m) {
                if (cnta == cntb) cnta = a[++u], cntb = b[++v];//当前元素相等，不用合并，移动到各自的下一个元素（前置++）
                else if (cntb > cnta) cnta += a[++u], ans++;//a小了，需要合并下一个元素，b不动
                else if (cnta > cntb) cntb += b[++v], ans++;
            }
            cout << ans << endl;
            return 0;
        }
        ```

双指针

1. [5.拔河 - 蓝桥云课](https://www.lanqiao.cn/problems/19713/learning/?page=2&first_category_id=1&second_category_id=3&tags=二分&tag_relation=union)

    分析：题目不要求学生全选，但要求保证顺序

    思路：

    - <font color=red>左右指针**标记左右**两队开始选人扩大力量的**端点**</font>
    - l<r,不断左移右移扩大队伍力量，使力量差距最小化

    代码：

    - ```cpp
        #include <iostream>
        #include <cstdio>
        #include <algorithm>
        #include <limits.h>
        #include <cmath>
        #define ll long long
        using namespace std;
        int a[105];
        //long long suma[105] ;
        int main()
        {
        	int n;cin>>n;
        	for (int i=1; i<=n; i++)cin >> a[i];//第i名同学的力量
        	//for (int i=1; i<=n; i++)suma[i] = suma[i-1] + a[i];
        	ll minans = INT_MAX; 
        	for (int l=1; l<n; l++)
        	{
        		for (int r=n; r>l; r--)
        		{//初始化左右端点的起始位置------------可以不全选，但要保证原有顺序!!!!
        			 int i=l,j=r;//使用i，j来扩大两个队伍 --------!!!!!!!!!
        			 ll sum1 = a[i], sum2 = a[j];
        			 while (i < j)
        			 {
        			 	if (sum1 == sum2)
        				{
        					cout << 0 << endl;
        					return 0;
        				}
        				else if (sum1 < sum2)
        				{
        					minans = min(minans, abs(sum1-sum2));//abs绝对值 
        					sum1 += a[++i];
        				}
        				else {
        					minans = min(minans, abs(sum1-sum2));
        					sum2 += a[--j];
        				} 
        			 }
        		}
        	}
        	cout << minans << endl;
        	return 0;
        }
        ```
        
    - 相当暴力的代码：肯定会TLE啦

        ```cpp
        //l -- i --- j---r
        for (int l=1; l<n; l++){
            for (int i=n-1; i>=l; i--){
                for (int j=i+1; j<=n; j++){
                    for (int r=n; r>=j; r--){
                        ll c1 = suma[i] - suma[l-1];
                        ll c2 = suma[r] - suma[j-1];
                        if (c1 > c2)
                            minans = min(minans, c1-c2);
                        else minans = min(minans, c2-c1);
                    }
                }
            }
        }
        ```

        

2. 



## 二分

1. [1.分巧克力 - 蓝桥云课](https://www.lanqiao.cn/problems/99/learning/?page=1&first_category_id=1&second_category_id=3&tags=二分&tag_relation=union)

    分析：边长区间在[1, ==**最大**巧克力边长==]，去猜（二分答案）

    思路：

    - 二分答案

    - <font color=red>计算每大块按此时猜测的最大边长mid，能切成几个小块</font>

        - ```cpp
            temp += p[i].first/mid * (p[i].second/mid);
            ```

    代码：

    - ```cpp
        #include <iostream>
        #include <cstdio>
        #include <map>
        #include <limits.h>
        #include <algorithm> 
        using namespace std;
        pair<int, int> p[100005];
        int main()
        {
        	int n, k; cin >> n >> k;//n块，k个小朋友 
        	int x = 1;//二分答案区间1~x 
        	for (int i= 1; i<=n; i++)
        	{
        		cin >> p[i].first >> p[i].second;//第i块f*s =h*w
        		int t = max(p[i].first, p[i].second);
        		x = max(x, t) ;
        	}
        	int l=1, r=x;//边长往最大边长猜 
        	int mid;
            int maxans=0;
        	int temp;//目前切出的正方形巧克力块数 
        	while (l <= r) 
        	{
        		mid = (l+r)/2;temp=0; 
        		for (int i=1; i<=n; i++)
        		{//---------------------------如何处理切？？？ 
        			temp += p[i].first/mid * (p[i].second/mid);
        		}
        		if (temp >= k)
        		{//合法，还能不能再大一点
        			maxans = max(mid, maxans);--------------//mid才是猜测答案哈 
        			l = mid+1;
        		}
        		else r=mid-1;
        	}
        	cout << maxans << endl;
        	return 0;
        }
        ```

2. [4.123 - 蓝桥云课](https://www.lanqiao.cn/problems/1591/learning/?page=1&first_category_id=1&second_category_id=3&tags=国赛,二分&tag_relation=intersection)

    分析：

    - 第i个区块有i个元素
    - 1≤*l~i~*≤*r~i~*≤10^12^，<font color=red>查找到li、ri的位置，让前缀和`sum[ri] - sum[li-1]`即为答案</font>
    - a[i]：**==前== i个小区间的元素个数**，同时也表示**==第==i个小区间的和**
    - sum[i]：前i个小区间的总和

    思路1：

    - 使用求和公式`(1+n)n / 2`找到li、ri的所在区间------O(1)

    思路2：

    - 使用二分查找li、ri的所在区间--------O(logn)

    代码：

    - ```cpp
        #include <iostream>
        #include <cmath>
        #define ll long long 
        using namespace std;
        int t;
        ll li, ri;
        ll m[1414221], sum[1414221];
        ll summ(ll x) 
        {
        	//二分查找-----x在哪个区间[1, 1414220]
        	ll l=1, r = 1414220, mid;
        	while (l <= r)
        	{
        		mid = (l+r)/2;
        		if (m[mid] > x)//个数和大于x，去左半边找
        			r = mid-1;
        		 else l = mid +1;
        	}
        	ll temp = x -m[r];//x在r+1区间里 
        	return sum[r] + (1+temp)*temp/2;//针对第r+1个小区间求和公式
        }
        int main()
        {
        	//(1+n)*n= 2e12
        	//cout << (long long)1414220*1414220;
        	//预处理找到至少1414220个小区间（粗略的） 
        	for (int i=1; i<=1414220; i++)
        	{
        		m[i] = m[i-1] + i;//第i个小区间数字的和，前i个小区间数字的个数和 
        		sum[i] = sum[i-1] + m[i];//前i个区间总和 
        	}
        	cin >> t;
        	while (t--){
        		cin >> li >> ri;
        		cout << summ(ri)-summ(li-1) << endl;//注意：利用前缀和求区间和下标是r-(l-1) = r-l+1
        	}
        	return 0;
        }
        ```

    感悟：

    - 前缀和的预处理功能----此题本质就是找到li、ri位置利用前缀和求区间和
        - 只不过本题的前缀和**单位元素**是一个小区间（123……）组成，而不是单个数
    - 不要光靠猪脑袋想，拿出草稿纸来推关系，得到公式

3. [8.卡牌 - 蓝桥云课](https://www.lanqiao.cn/problems/2191/learning/?page=1&first_category_id=1&second_category_id=3&tags=二分,国赛&tag_relation=intersection)

    分析：

    - 暴力思路
    - 二分答案，可以组成了完整扑克牌数

    



## 位运算

1. [6.妇女唇膏【算法赛】 - 蓝桥云课](https://www.lanqiao.cn/problems/20265/learning/?contest_id=249)

    分析：`a+b = a^b`     等价于   `a&b=0`

    - 左式为有进位加法，右式^又称无进制加法。二者运算结果相同，说明没有发生进位，即A中所有数的某一二进制位i上都是0，答案也就是`1<<i`(i>=0)

    思路：

    - <font color=red>可以先将所有A值或`|`起来，全为0的二进制位bit或后仍为0</font>，我们去枚举寻找最小的0二进制位lowbit即可
    - 输出`1<<i`

    代码：

    - ```cpp
        #include <iostream>
        using namespace std;
        int a[100005];
        int main()
        {
        	int n;cin >> n;
        	int ans=0;
        	for (int i=1; i<=n; i++)
        	{
        		cin >> a[i];
        		ans |= a[i];//所有a值或在一起，找到lowbit为0的位置i 
        	}
        	for (int i=0; i<n; i++)
        	{
        		if ((ans>>i & 1) == 0)
        		{
        			cout << (1<<i) << '\n';//左移i位，添i个0
        			return0;
        		}
        	}
        	//return 0;
        }
        ```

    - ```cpp
        #include <iostream>
        using namespace std;
        int main() {
          int n,x,ans = 0;
          cin>>n;
          for (int i=1; i<=n; i++)cin>>x, ans |= x;
          cout<<(~ans&-~ans)<<'\n';
          return 0;
        }
        ```

## DFS

1. [1.五子棋对弈 - 蓝桥云课](https://www.lanqiao.cn/problems/19694/learning/?page=1&first_category_id=1&second_category_id=3&name=五子棋)

    分析：

    - 深搜二维棋盘<img src="D:\Node-typora\note-picture\749584ff6abc617d767a85f6fe2c0465_720.jpg" alt="749584ff6abc617d767a85f6fe2c0465_720" style="zoom: 25%;" />==dfs (depth, white, black)==,**depth∈[0, 25]**
    - ==一维深度转二维下标：==
        - <font color=red>x=depth /5;	y=depth%5</font>

    思路：

    - 深搜dfs(0, 0, 0):初始位置0开始深搜，此时白棋黑棋均为0
    - 当深搜到depth=25，判断white白棋子= =13、black黑棋= =12
        - 判断是否和棋----横纵交叉4个方向----和棋ans++

    代码：

    - 正解：

        ```cpp
        #include <iostream>
        using namespace std;
        int desk[5][5], ans;//0~4
        bool check()
        {//上下左右主副对角,即横纵交叉（4个方向） 
        	int s1, s2, s3, s4;s1=s2=s3=s4=0;//------------------高级的判断方法，搞自己 
        	for (int i=0; i<5;i++)
        	{
        		s1=s2 =0;//重置 
        		for (int j = 0; j<5;j++)
        		{
        			if(desk[i][j]==1) s1++;//横 
        			if (desk[j][i]==1) s2++;//纵 
        			//if (i==j && desk[i][j]==1)s3++; //主对角 --只有5个，不用初始化 
        			//////////if(i==4-j )s4++; //副 ------------未解之谜（应该是重复判断了） 
        		}
        		if (desk[i][i]==1)s3++;//主
        		if(desk[i][4-i])s4++;//副 ----***
        		if (s1 == 5 || s1==0 || s2==5 ||s2==0) return false;
        	}
        	if (s3 == 5 || s3==0 || s4==5 || s4==0) return false;
        	else return true;//和棋 
        }
        void dfs(int depth, int w, int b)
        {
        	//if (depth ==25 && w==13 && b==12 && check())//&&短路 
        	if (depth==25){
        		if (w==13 && b==12 && check())ans++;
        		return;//depth==25无论是否和棋都要返回 
        	}
            //一维深搜路径-->二维
        	int x = depth/5;
        	int y = depth%5;
            //深搜位置两种放法
        	desk[x][y] = 1;//1表示白棋---放白棋 
        	dfs(depth+1, w+1, b);
        	desk[x][y] = 0;//-----------回溯后+放黑棋 
        	dfs(depth+1, w, b+1);
        }
        int main()
        {
        	dfs(0, 0, 0);
        	cout << ans << endl;
        	return 0;
        }
        ```

    - 问题代码（TLE）:[依托答辩代码-CSDN博客](https://blog.csdn.net/2303_80917973/article/details/147050994?spm=1001.2014.3001.5502)


    <font color=blue>感悟：</font>
    
    - 深搜dfs的本质，就是枚举该深度的所有可能-------棋子选择、搜索方向等等
    - 一维深度---->二维坐标（好用记下来）

2. [1.路径之谜 - 蓝桥云课](https://www.lanqiao.cn/problems/89/learning/?page=1&first_category_id=1&second_category_id=3)

    分析：

    - 深搜上下左右四个方向

    - <font color=red>二维坐标---->一维深搜深度</font>

        - 0 ~ n-1或1 ~ n都可以，一定要明确

    - 深搜+递归----**结束条件为**

        - 1.step==0;（给定步数用尽）-----还得判断是否到达终点
        - 2.depth=n*n-1（到达终点）-------------递归出口的选取

    - **问：**无论那个都要去**判断靶子数是否刚好用尽**吗？

        - <img src="D:\Node-typora\note-picture\image-20250408164551612.png" alt="image-20250408164551612" style="zoom: 25%;" />

        - **答：**不是的，只要严格满足==靶子数以内==来深搜，找到的终点就一定是唯一答案路径

            ```cpp
            if (row[x]<=0 || col[y]<=0)continue;//访问到新位置(x，y)，必然会让行、列靶子数都--
            ```

思路：

- 定义row[],col[]分别读入横纵靶子数

- tips：<u>定义dx[],dy[]为深搜四个方向做准备</u>------------------常用

    - ```cpp
        int dx[4] = {0, 1, 0, -1};//右下左上 
        int dy[4] = {1, 0, -1, 0};
        ```

    - 选择优先的深搜路径也是很有必要的</font>

- 定义step总步数=sum(row[])，**每走一步，step--**

    - （避免另弄一个sum++与其作比较）
    - 也是可以作为递归出口的判断条件

- 注意边界情况，不可以越界。<font color=red>使用visit访问数组[ ] [ ]</font>

代码：

- 正解：

    ```cpp
    #include <iostream>
    #include <vector>
    using namespace std;
    int row[21], col[21];//行，列靶子数 
    vector<int> path;
    int step;//总步数
    int n, vis[21][21]; 
    int dx[4] = {0, 1, 0, -1};//右下左上 
    int dy[4] = {1, 0, -1, 0};
    void print()
    {
    	for (int i=0;i<path.size();i++)cout << path[i] << ' ';
    	cout << endl;
    }
    void dfs(int a, int b)
    {
    	//目标状态1.达到终点  2.达到步数step==0（还要在判断是否用尽步数到达的是终点） 
    	//这么看来其实弄一个步数判断似乎是多余的，只要到达终点，**并且是按照规定的靶子数路径则为答案路径 **
        //步数可以用来剪枝？？
    	if (step==0) 
    	{
    		if (a*n+b == n*n-1) 
    		{//是终点 
    			/*for (int i=0;i<n;i++)
    			{
    				if(row[i] !=0 || col[i]!=0)return;//不合法 
    			}*/
    			print(); 
    		}
    		return; //路径唯一递归出口 
    	}
    	//以(a，b)为源点深搜
    	for (int i=0;i<4;i++)
    	{
    		int x = a + dx[i];int y = b+dy[i];
    		//(x,y)是否可以访问
    		if (x<0 || x>=n || y<0||y>=n) continue;
    		if (row[x]<=0 || col[y]<=0)continue;//访问到（x，y），必然会让行列靶子数都--
    		if (vis[x][y] ==1)continue;
    		//else
    		vis[x][y] = 1;
    		step--;row[x]--;col[y]--;
    		path.push_back(x*n+y);
    		dfs(x, y);
    		//回溯
    		vis[x][y] = 0;
    		step++;row[x]++;col[y]++;
    		path.pop_back();
    	}
    }
    int main()
    {
    	cin >> n;
    	for (int i=0;i<n;i++)cin>>col[i];//先列
    	for (int i=0;i<n;i++) 
    	{
    		cin >> row[i];step += row[i];
    	}
    	//从入口开始搜 
    	vis[0][0] = 1;
    	row[0]--;col[0]--;step--;
    	path.push_back(0);
    	dfs(0,0);//0~n-1
    	return 0;
    }
    ```

- 依托答辩（答辩第二版，第一版更答辩）

    ```cpp
    #include <iostream>
    #include <cstdio>
    #include <vector>
    using namespace std;
    int n, x[21], y[21];//靶子
    int visit[21][21];//位置是否访问，1访问过 
    int dx[4] =	{0, 1, 0, -1};	
    int dy[4] = {1, 0, -1, 0};	//右下左上 
    int step;//总步数 
    vector<int> ans;//答案路径 
    void print()
    {
    	for (int i=0;i<ans.size();i++)cout << ans[i] << ' ';
    	cout << endl;
    }
    void dfs(int i, int j)
    {
    	if (step == 0) 
    	{
    		if ((j-1)+(i-1)*n == n*n-1)//错误2：-------------没有检测靶子数是否耗尽(????step耗尽，难道？) 
    		{
    			for (int k=1;k<=n;k++) 
    			{
    				if (x[k]!=0 || y[k] != 0)return ;
    			}
    			print();
    		}
    		return;
    	}
    	//深搜右下左上？？？？ ---答：方向很有所谓---选择不当会TLE 
    	for (int m=0;m <4;m++) 
    	{
    		//i+=dx[m];j+=dy[m];//错误1------直接修改了i，j,导致后续方向遍历时坐标混乱。 下一次循环的坐标已经是修改后的值，而非原始起点
    		int xx=i+dx[m]; int yy = j+dy[m];
    		if (visit[xx][yy] == 1) continue;			 //该方向已经访问过
    		if (xx>n || xx<1 || yy>n || yy<1)  continue;//不合法方向 
    		if (x[xx]<=0 || y[yy]<=0) continue;			//某个方向步数达到了限定 
    		//否则去访问它 
    		visit[xx][yy] = 1;
    		x[xx]--;y[yy]--;
    		step--;
    		int t = (xx-1)+(yy-1)*n;
    		ans.push_back(t); //二维转一维***** 
    		dfs(xx, yy);
    		//回溯
    		visit[xx][yy] = 0;
    		x[xx]++;y[yy]++;
    		step++;
    		ans.pop_back();
    	}
    }
    int main()
    {
    	cin >>n;
    	for (int i=1; i<=n; i++)
    	{
    		cin >> y[i];//1~n
    		step += y[i];
    	}
    	for (int i=1;i<=n;i++)cin >> x[i];
    	//起点出发
    	visit[1][1]=1;x[1]--;y[1]--;step--;
    	ans.push_back(0);
    	dfs(1, 1);//以1，1为源点深搜 
    	return 0; 
    }
    ```

<font color=blue>感悟：</font>

- ==dfs大致模板==：

    ```cpp
    function dfs(---)
    {
        if (新状态==目标状态)
        {
            //进一步判断
            //dosoming
            return;
        }
        深搜所有方向/新状态
        for (---)
        {
            if (该新状态是否合法/有没有被访问)
            {
                访问这个新状态
                //do someing
                dfs(更新为新状态);
                //也可以加一些剪枝操作--毕竟dfs就是暴力深搜
                //是否需要回溯？统计某点能到达的点的个数一般不用
                回溯，退回原状态
            }
        }
    }
    ```

- 深搜函数的参数表

    1. ```cpp
        dfs([深度depth]，各种判断变量， 各种状态量);//[]：表示可有可无
        ```

    2. ```cpp
        全局变量
        dfs();
        ```

    3. ```cpp
        全局判断变量
        dfs([depth]，各种状态量)------------推荐
        ```

3. [19.数字接龙 - 蓝桥云课](https://www.lanqiao.cn/problems/19712/learning/?page=1&first_category_id=1&second_category_id=3&tags=2024&tag_relation=intersection)

    分析：

    - 起点必须是0，终点不一定是k-1，但一定是按顺序走的
    - 不可以交叉，特殊重点判断

    思路：

    - 常见dfs模板思路
    - 重难点---解决**判断是否交叉**
        - <img src="D:\Node-typora\note-picture\3be635dfbe1ccf187c7bcf0ac2c609ba_720.jpg" alt="3be635dfbe1ccf187c7bcf0ac2c609ba_720" style="zoom:25%;" />
        - ![image-20250411153054889](D:\Node-typora\note-picture\image-20250411153054889.png)

    代码：

    - 过75%样例代码

        ```cpp
        #include <bits/stdc++.h>
        using namespace std;
        int n, k, desk[13][13], vis[13][13];//还不能交叉 
        vector<int> ans;
        int dx[8] = {-1, -1, 0, 1, 1, 1, 0, -1};
        int dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};
        int cnt;//存在多条路劲，只打印字典序最小的一条 
        int flag;//输出-1 
        void print()
        {
        	for (int i=0; i<ans.size(); i++)cout << ans[i];
        	cout << endl;
        }
        bool check(int i, int x, int y)
        {//这种检查方式欠妥
        	if (i == 1)
        	{
        		if (vis[x-1][y] == 1 && vis[x][y+1] == 1)return false;
        	}
        	else if (i==3)
        	{
        		if (vis[x+1][y] == 1 && vis[x][y+1] == 1)return false;
        	}
        	else if(i == 5)
        	{
        		if (vis[x+1][y] == 1 && vis[x][y-1] == 1)return false;
        	}
        	else if (i == 7)
        	{
        		if (vis[x][y-1] == 1 && vis[x-1][y] == 1)return false;
        	}
        	return true;
        }
        void dfs(int x, int y, int s)
        {
        	if (x == n-1 && y == n-1)
        	{
        		if (ans.size() != n*n-1)
        		{//没有遍历完整一遍 
        			return; 
        		}
        		cnt++;
        		if (cnt <=1) print();
        		flag =1; 
        		return;
        	}
        	//0~7八个方向 
        	for (int i=0; i<8; i++)//字典序 
        	{
        		int xi = x+dx[i];
        		int yi = y + dy[i];
                //检查新状态点（xi，yi）是否可以搜
        		if (xi<0 || xi >=n || yi <0 || yi >= n)continue;
        		if (vis[xi][yi] == 1)continue;
        		if (desk[xi][yi] != (s+1)%k)continue;
        		if (i==1 || i==3 ||i==5 || i==7)
        		{
        			if (!check(i, x, y))continue;
        		}
        		//else
        		vis[xi][yi] = 1;
        		ans.push_back(i);
        		dfs(xi, yi, s+1);
        		//huisu
        		vis[xi][yi] = 0;
        		ans.pop_back();
        	}
        	//走不通
        	return; 
        }
        int main()
        {
        	cin>>n >> k;
        	for (int i=0; i<n;i++)
        	{
        		for (int j=0; j<n; j++)
        			cin >> desk[i][j];	
        	}
        	int step = 0;
        	vis[0][0] = 1;
        	dfs(0, 0, step);//深搜位置，步数（对k取余） 
        	if (flag == 0)cout << -1 << endl;
        	return 0;
        }
        ```

4. [P1219 USACO1.5\] 八皇后 Checker Challenge - 洛谷](https://www.luogu.com.cn/problem/P1219)

    分析：

    - <img src="D:\Node-typora\note-picture\image-20250411132835601.png" alt="image-20250411132835601" style="zoom:25%;" />

    思路：

    - 常见dfs模板思路
    - 检查check在该位置放皇后，其攻击范围没有其他皇后

    代码：会<font color =red>超时一个样例--TLE</font>

    - ```cpp
        #include <bits/stdc++.h>
        using namespace std;
        vector<int> col;//列 ---输出皇后放置的列数 
        int vis[14][14];//放一个皇后，要改八个方向 ！！ 
        int ans, n; 
        void print()
        {
        	for (int i= 0; i<col.size(); i++)cout << col[i]<< ' ';
        	cout << endl;
        }
        void attack(int r, int c){}
        void disattack(int r, int c){}
        //注意：之前皇后的位置不能干掉 
        bool check(int r, int c)
        {//该皇后攻击范围没有其他皇后
        	for (int i=1; i<=n; i++){
        		if (vis[i][c] == 1)return false;
        		if (vis[r][i] == 1)return false;
        	}
        	//左上
        	int t1, t2;t1 = r;t2 = c;
        	while (t1>0 && t2>0) {
        		if (vis[t1--][t2--] == 1)return false;
        	}
        	t1 = r;t2 = c;
        	while (t1 <= n && t2 <= n){
        		if (vis[t1++][t2++] == 1)return false;
        	}
        	t1 = r;t2 = c;
        	while (t1 >0 && t2 <= n)//youshang
        	{
        		if (vis[t1--][t2++] == 1)return false;
        	}
        	t1 = r;t2 = c;
        	while (t1 <= n && t2 >0){
        		if (vis[t1++][t2--] == 1)return false;
        	}
        	return true; 
        }
        void dfs(int q, int row) 
        {
        	if (q > n)//if (col.size() == n)皇后都放完了 
        	{
        		ans++;
        		if (ans <= 3)print();
        		return ;
        	}
        	//在第row行，放第q个皇后 
        	for (int i=1; i<=n; i++)
        	{
        		if (vis[row][i] == 0&& check(row, i))
        		{
        			//放置
        			//attack(row, i);
        			vis[row][i] = 1;
        			col.push_back(i);
        			dfs(q+1, row+1);//下一行放下一个皇后 
        			//disattack(row, i);//取消这个皇后 
        			//之前放置的皇后的攻击范围要保留 
        			vis[row][i] = 0;
        			col.pop_back();
        		}
        	}
        }
        int main()
        {
        	cin >> n;
        	dfs(1, 1);//放棋子（皇后） //漏了条件哈-------以某个皇后为中心，上下左右四斜都不能有其他皇后，不能相互攻击 
        	cout << ans << endl;
        	return 0;
        }
        ```

    - 需要对以上代码进行==剪枝==



## 数学

1. [1.阶乘约数 - 蓝桥云课](https://www.lanqiao.cn/problems/1020/learning/?page=1&first_category_id=1&second_category_id=3&tags=数学&tag_relation=intersection)

    分析：

    - 唯一分解定理：对于一个<u>大于1</u>的整数n，可以将n分解为一些质因数的**幂次和**

    - 约数定理

        - 约数个数定理：

            - 若一个数分解质因数为 *n*=*p*1^a1^×*p*2^a2^×⋯×pk^ak^，则其正约数的个数为：(*a*1+1)(*a*2+1)…(*ak*+1)

                例如：12=22×31，正约数个数为 (2+1)(1+1)=6 个------即(幂次+1)累乘

        - 约数和定理：

            - 所有<u>正约数</u>的和可通过以下公式计算：

                (*p1*^0^+*p1*^1^+⋯+*p*1^a1^)×⋯×(pk^0^+*pk*^1^+⋯+*pk^ak^*)

                例如：360=23×32×51，其**约数和**为 (1+2+4+8)(1+3+9)(1+5)=1170

    - **Legendre公式计算质因数指数**-------------有待学习

        - 在阶乘*n*!中，质数*p*的指数*a~p~*可通过公式：

            - a~p~ = Σ(k=1,∞)[n / p^k^]<img src="D:\Node-typora\note-picture\image-20250503153337684.png" alt="image-20250503153337684" style="zoom: 50%;" />

            例如，计算100!中**质数2**的指数：

            ⌊100/2⌋+⌊100/4⌋+⌊100/8⌋+⋯=50+25+12+6+3+1=97

    思路：

    - 得到100以内的所有质数，并建立质数数组
    - 通过循环质数数组得到<u>100!中1~100数可分解为的</u>质数的幂次
        - 100!唯一分解成质数幂次积形式 ==<=等价于=>== 1~100**分别分解**成质数幂次积**的积**形式
        - 统计每个质数的幂次数
    - 对每个质数的**（幂次数+1）进行累乘**，得到答案

    代码：

    - ```cpp
        #include <iostream>
        #define ll long long
        using namespace std;
        int main()
        {
          int prime[] = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};
          ll ans = 1;
          for (int i=0; i<sizeof(prime)/sizeof(prime[0]); i++){
          	int cnt = 0, n=100;
          	while (n != 0){
          		cnt += (n /= prime[i]);//Legendre公式
                //拿质数2，4，8，16举例，通过改变n的值，实现依次计算除2、4、8的幂次数，求和
        	}
        	ans *= cnt+1;
          }
          cout << ans << endl;
          return 0;
        }
        ```

    - ```cpp
        
        ```

2. [2.循环小数 - 蓝桥云课](https://www.lanqiao.cn/problems/1051/learning/?page=1&first_category_id=1&second_category_id=3&tags=数学&tag_relation=intersection)

    分析：

    - <img src="D:\Node-typora\note-picture\d20f7a6b649fa2bf433116734050023c_720.jpg" alt="d20f7a6b649fa2bf433116734050023c_720" style="zoom:50%;" />

    思路：

    - 定义并获取核心公式中的四个变量：k、l、m、n
    - 算分子、分母
    - 应题意要求，所以要对分子分母除以最大公约数gcd，得到最简真分数

    代码：

    - ```cpp
        #include <iostream>
        #include <string>
        #include <cmath>
        #define ll long long
        using namespace std;
        int p, q;
        ll k, l, m, n;
        ll x, y;//分子，分母 
        ll gcd(ll a, ll b){
        	return b==0? a: gcd(b, a%b);
        }
        int main()
        {
        	cin >> p >> q;
        	string s;cin >> s;
        	m = p-1, n = q-p+1;
        	int t1=m, t2 = n;
        	for (int i=0; i<m; i++)
        	{
        		k += (s[i]-'0') * pow(10, t1-1);
        		t1--;
        	}
        	for (int i=p-1; i<q; i++)
        	{
        		l += (s[i]-'0') * pow(10, t2-1);
        		t2--;
        	}
        	//得到了k、l、m、n，运用公式求解
        	x = k * (pow(10, n)-1) + l;
        	y = (pow(10, n) - 1) * pow(10, m);
        	ll temp = gcd(x, y);
        	cout << x/temp << ' ' << y/temp << endl;
        	return 0;
        }
        ```



# 蓝桥算法赛

## 28-入门

1. [3.蓝桥速算【算法赛】 - 蓝桥云课](https://www.lanqiao.cn/problems/20290/learning/?contest_id=253)

    分析：

    - 不需要对区间进行操作
        - 区间变换一增一减,单位置增减**下标值**
    - 只需要对区间数分析即可
        - 1.区间数r-l+1为偶数，总数sum -= 偶数/2
        - 2.<font color=red>为奇数，除最后一个数外，先按情况1.减去偶数/2，在加r即可</font>

    思路+核心代码：

    - ```cpp
        while (q--){
            cin >> l >> r;
            if (l == r)sum += l;//可省
            else if ((r-l+1)%2 == 0)sum -= (r-l+1)/2;
            else sum = sum - (r-l+1-1)/2 + r;
            //奇数-1得到偶数，-1*偶数/2，最后+r就行
        }
        ```

    感悟：

    - 我的**错误**思想：为奇数是，是sum加上（奇数+1）/2

2. [4.浓缩咖啡液【算法赛】 - 蓝桥云课](https://www.lanqiao.cn/problems/20289/learning/?contest_id=253)

    分析：高h + 低low 才可以配m

    代码：

    - ```cpp
        while (t--){
            cin >> n >> m;
            int h=0, low=0;//高+低才能得到目标
            //记得重置条件--------****
            for (int i=1; i<=n; i++){
                cin >> a[i];
                if (a[i] > m)h++;
                else if (a[i] < m)low++;
                else if (a[i] == m){
                    h++,low++;
                    //break;
                    //---这里不可以剪枝
                }
            }
            if(h && low)cout << "YES" << endl;
            else cout << "NO" << endl;
        }
        ```

    感悟：

    - 循环判断时，判断条件的重置变量的重要性，容易遗忘
    - 测试用例的固定输入：贸然剪枝就会导致
        - 剩余输入数据残留在输入流中，后续测试用例会读取到错误的数据，产生连锁错误

3. [5.破译密码【算法赛】 - 蓝桥云课](https://www.lanqiao.cn/problems/20288/learning/?contest_id=253)

    分析：

    - ==Johnson算法==---流水作业
        - <img src="D:\Node-typora\note-picture\image-20250504194528657.png" alt="image-20250504194528657"  />
        - （所以**不可以挑**破译好的多个芯片传输）

    思路：

    - 将芯片分为两批x, y，破译a>=传输b，破译<传输。
    - 对x按a升序排列，对y按b降序排列
    - 得到处理芯片的顺序 = x.no+y.no
    - <font color=red>模拟甘特图，计算最短所需时间</font>

    代码：

    - ```cpp
        #include <bits/stdc++.h>
        using namespace std;
        struct node{
        	int a, b;
        	int no;
        }c[1005];
        int n;
        vector<node> x, y;//按Johnson算法分为两部分 
        bool cmp1(node t1, node t2){
        	return t1.a < t2.a;
        }
        bool cmp2(node t1, node t2){
        	return t1.b > t2.b;
        }
        int main()
        {
        	cin >> n;
        	for (int i=1; i<=n; i++){
        		cin >> c[i].a;c[i].no = i;
        	}
        	for (int i=1; i<=n; i++)cin >> c[i].b;
        	for (int i=1; i<=n; i++)
        	{//分组
        		if (c[i].a <= c[i].b)x.push_back(c[i]);
        		else y.push_back(c[i]);
        	}
        	sort(x.begin(), x.end(), cmp1);//vector数组使用begin和end
        	sort(y.begin(), y.end(), cmp2);
        	//模拟甘特图---芯片处理顺序x.no-->y.no
        	int temp[1005] = {0};//vector使用size获取长度，string可size可length
        	for (int i=0; i<x.size(); i++)temp[i] = x[i].no;
        	for (int i=x.size(), j=0; j<y.size(); j++){
        		temp[i+j] = y[j].no;
        	}
        	//模拟
        	int atime=0, btime=0;
        	for (int i=0; i<x.size()+y.size(); i++) 
        	{
        		atime += c[temp[i]].a;
        		if (btime < atime){
        			btime = atime;//需要等 
        		}
        		btime += c[temp[i]].b;
        	}
        	cout << btime << endl;
        	return 0;
        }
        ```
        
    - ```cpp
        #include <iostream>
        #include <algorithm>
        using namespace std;
        pair<int, int> a[1005];//本质就是个结构体，都行
        int main() {
          int n;
          cin>>n;
          for (int i=1; i<=n; i++)cin>>a[i].first;
          for (int i=1; i<=n; i++)cin>>a[i].second;
          sort(a+1, a+1+n, [](auto& p1, auto& p2) 
               {
            auto group1 = (p1.first <= p1.second);
            auto group2 = (p2.first <= p2.second);
            if(group1 != group2) return group1 > group2;
            return group1 ? (p1.first < p2.first) : (p1.second > p2.second);
               }
          );
          int ans = 0, t = 0;
          for (int i=1; i<=n; i++)
            t += a[i].first, ans = max(ans, t) + a[i].second;
          cout<<ans<<'\n';//t解码时间大于传输时间，需要等
          return 0;
        }
        ```

    感悟：

    - 广泛学习的重要性，模拟能力的硬实力

    

4. [6.插入数字【算法赛】 - 蓝桥云课](https://www.lanqiao.cn/problems/20291/learning/?contest_id=253)

    分析：

    - <font color =red>数据范围都到10^18^，第一想到大概率是规律题了</font>
    - 沉住心来列几个数，找一找规律

    思路：

    - 列9、985、10、999（本质与各位互不相同的数一样）、9909、990等等
    - 某数的左右两空，**不可以都填**与该数相同的两数，否则会导致重复
        - _ 9 _ 9 _ 9 _，第二个空0~8，虽说没填9(二三空之间夹着的数是9)，但第三个空也不能填9，导致仍然只能填9种

    代码：

    - ```cpp
        string n;cin >> n;
        cout << 9 * (n.size()+1) << endl;
        ```

    感悟：耐心和总结，拿下规律题



## 29-挑战

1. [3.blue密钥【算法赛】 - 蓝桥云课](https://www.lanqiao.cn/problems/20324/learning/?contest_id=256)

    分析：

    WA代码：

    - ```cpp
        #include <iostream>
        #include <string>
        using namespace std;
        string s;
        int cnt[5];
        char f[5];
        int main()
        {
          //暴力检查四连的这4个位置有点多少blue在对应的位置上
          //答案是在对应位置上的最少字符个数
          cin >> s;
          f[0] = 'b';
          f[1] = 'l';
          f[2] = 'u';
          f[3] = 'e';
          //让数四连的起始点动起来，刚刚只是固定在0位置
          for (int i=0; i<4; i++)
          {
            for (int j=i; j<s.size(); j+=4)
            {
              if (s[j] == f[i])cnt[i]++;
            }
          }
          int ans1 = cnt[0];
          for (int i=1; i<4; i++)
            cnt[i]<ans1?ans1=cnt[i]:0;
        
          
          //动起来----最简单的丑陋枚举枚举
          f[0] = 'e';
          f[1] = 'b';
          f[2] = 'l';
          f[3] = 'u';
          for (int i=0; i<4; i++)
          {
            for (int j=i; j<s.size(); j+=4)
            {
              if (s[j] == f[i])cnt[i]++;
            }
          }
          int ans2 = cnt[0];
          for (int i=1; i<4; i++)
            cnt[i]<ans2?ans2=cnt[i]:0;
        
          //
          f[0] = 'u';
          f[1] = 'e';
          f[2] = 'b';
          f[3] = 'l';
          for (int i=0; i<4; i++)
          {
            for (int j=i; j<s.size(); j+=4)
            {
              if (s[j] == f[i])cnt[i]++;
            }
          }
          int ans3 = cnt[0];
          for (int i=1; i<4; i++)
            cnt[i]<ans3?ans3=cnt[i]:0;
          //
          f[0] = 'l';
          f[1] = 'u';
          f[2] = 'e';
          f[3] = 'b';
          for (int i=0; i<4; i++)
          {
            for (int j=i; j<s.size(); j+=4)
            {
              if (s[j] == f[i])cnt[i]++;
            }
          }
          int ans4 = cnt[0];
          for (int i=1; i<4; i++)
            cnt[i]<ans4?ans4=cnt[i]:0;
          //结束，取最多拼凑的数量
          int ans =0 ;
          ans1 > ans2? ans = ans1:ans = ans2;
          ans > ans3? 0:ans = ans3;
          ans > ans4? 0: ans = ans4;
        
          cout << ans << endl;
          return 0;
        }
        /*
         |s|是4的倍数
        
        可多次任选s上的位置i，交换i与i+4的内容
        通过交换，拼凑出blue字样
        - 结论，一个字符只能在四个连续字符的位置上进行交换
        -     例如，b在一个四连的第二个位置通过交换它可以到
                    另一个四连的第二个位置
        
        -   直接用这个结论解题是错的，因为数四连的位置不固定啊
        
        
        问最多拼多少个blue
        */
        ```

    AC代码：

    - ```cpp
        #include<bits/stdc++.h>
        #define ll long long
        using namespace std;
        ll a[4][1000];//0、1、2、3四个位置的各字符的数量（字符作下标）
        string s;
        int main(void) 
        {
            cin>>s;
            for(ll i=0;i<s.length();i++){
              a[i%4][s[i]]++;//0,1,2,3各位置字符数，s[i]字符做下标
            }
            ll ans=0;
            for(ll i=0;i<s.length()-3;i++)	//枚举到len-3为止，加上本身和最后三个字符，凑最后一个可能密钥 
        	{
                if(a[i%4]['b']>0){
                    if(a[(i+1)%4]['l']>0){
                        if(a[(i+2)%4]['u']>0){
                            if(a[(i+3)%4]['e']>0)
        					{
                                a[i%4]['b']--;
                                a[(i+1)%4]['l']--;
                                a[(i+2)%4]['u']--;
                                a[(i+3)%4]['e']--;
                                ans++;
                                i+=3;//配合i++,相当于i+=4连续判断下一个完整（4个为一组）可能的密钥 
                            }
                            //当以上条件不能同时满足时，只i++，换个blue的起始点枚举判断b-l-u-e 
                        }
                    }
                }
            }
            cout<<ans;
            return 0;    
        }
        ```

    - 









# 洛谷题单

## 暴力枚举

1. [P2089 烤鸡 - 洛谷](https://www.luogu.com.cn/problem/P2089)

    分析：直接开10个变量表示10种调料

    思路：

    - 暴力枚举
    - 最下层的for循环，数字++，满足条件输出时<font color=red>自然符合题目对字典序的要求</font>

    代码：

    - ```cpp
        #include <iostream>
        using namespace std;
        int main()
        {
        	int a,b,c,d,e,f,g,h,i,j, ans=0, n;
        	cin >> n;
        	//O(3^10)=O(9^5)
        	for (int a=1; a<=3; a++)
        	for (int b=1; b<=3; b++)
        	for (int c=1; c<=3; c++)
        	for (int d=1; d<=3; d++)
        	for (int e=1; e<=3; e++)
        	for (int f=1; f<=3; f++)
        	for (int g=1; g<=3; g++)
        	for (int h=1; h<=3; h++)
        	for (int i=1; i<=3; i++)
        	for (int j=1; j<=3; j++)
        	{
        		if (a+b+c+d+e+f+g+h+i+j == n)ans++;
        	}
        	cout << ans <<'\n';
        	for (int a=1; a<=3; a++)
        	for (int b=1; b<=3; b++)
        	for (int c=1; c<=3; c++)
        	for (int d=1; d<=3; d++)
        	for (int e=1; e<=3; e++)
        	for (int f=1; f<=3; f++)
        	for (int g=1; g<=3; g++)
        	for (int h=1; h<=3; h++)
        	for (int i=1; i<=3; i++)
        	for (int j=1; j<=3; j++)//从最后一位增大，天然满足字典序 
        	{
        		if (a+b+c+d+e+f+g+h+i+j == n)
        		{
        			cout << a << ' ';cout << b << ' ';
        			cout << c << ' ';cout << d << ' ';
        			cout << e << ' ';cout << f << ' ';
        			cout << g << ' ';cout << h << ' ';
        			cout << i << ' ';cout << j << ' ';
        			cout << '\n';
        		}
        	}
        	return 0 ;
        }
        ```

2. [P2392 kkksc03考前临时抱佛脚 - 洛谷](https://www.luogu.com.cn/problem/P2392)

    分析：

    - 左右脑双核解题，尽量让左右脑耗时差距最小

    思路：

    - 错误思路：排序后+贪心

        - 错误样例：比如 7 6 6 4 3的情况
            7	7	7 + 4	7 + 4 + 3
            6	6 + 6  6 + 6	6 + 6 

            这里是14:12。然而正解：

            7 + 6
            6 + 4 + 3。结果是13:13
            
        - 再来个更简单的例子：1、2、3、4

            - 贪心：1+3、2+4
            - 显然正解是：1+4、2+3

    - 正确思路：dp（01背包）  or   ==递归枚举(暴力)==

    代码：

    - 递归：每一个既可以放左脑处理也可以放右脑处理，最终时间复杂度：O2^n^

        ```cpp
        ```

        

3. [P1036 NOIP 2002 普及组\] 选数 - 洛谷](https://www.luogu.com.cn/problem/solution/P1036)

    分析：

    - 保障补充不重不漏选k个数，采用==不降原则==：**不对具体的数字不降原则，而是对下标不降原则**
        - 解决这个问题的策略即**不降原则**，具体如下：
            - 第一个数在 1∼6 枚举，设为 *x*1。
            - 第二个数在 *x*1+1∼6 枚举，设为 *x*2。
            - 第三个数在 *x*2+1∼6 枚举，设为 *x*3。

    思路：

    - 模拟选数过程-----使用递归--dfs函数
        - 递归出口当然就是选出了k个数
    - 求和判素数isprime()

    代码：

    - ```cpp
        #include <iostream>
        #include <cstdio>
        using namespace std;
        int n;
        int a[11], flag[11];//标记数组i位置是否使用，1使用，0未使用 
        void dfs(int pos)
        {//填第pos个位置
        	if (pos > n)
        	{//填好了 
        		for (int i=1;i<=n;i++)
        			printf("%5d", a[i]);
        		printf("\n");
        		return;
        	}
        	for (int i=1; i<=n; i++)//1~n选数填
        	{
        		if (flag[i]==0)//选未使用过的
        		{
        			a[pos] = i;
        			flag[i] = 1;
        			dfs(pos+1);//递归填完输出返回
        			flag[i] = 0;//回溯 --该位置也可以填其他数
        		}
        	}
        }
        int main()
        {
        	cin >> n;
        	dfs(1);//填第一个位置
        	return 0; 
        }
        ```

4. [P3799 小 Y 拼木棒 - 洛谷](https://www.luogu.com.cn/problem/P3799)

    要求：

    - n根火柴选4根拼正三角形，求可选方案数（答案对 10^9^+7 取模）

    分析：

    - <font color=red>n根选4根组成正三角形，则必然两根长度相等为i，另外两根拼凑长度为i</font>
    - 暴力枚举长度（≤5×10^3^）两层for循环就能过

    思路：

    - 1.找两根长度为`i`的数，组合**C(numi, 2)**
        - <font color=red>外循环，一定要先找到两根相同的长度为i的火柴，**才能进入内循环**</font>

    - 2.找另外两根长度为`j`和`i-j`的数--------内循环
        - j = i-j：**C(numj, 2)**
        - j!=i-j：**C(numj, 1)** * **C(numi-j, 1)**
    - 注意：
        - 输入是初始化各长度火柴的数量，<u>找到最长长度用于枚举</u>
        - 每一步都要对`1e9+7`取余
        - 利用<font color=red>乘法原理</font>
        - 写个组合函数，只需要**满足取1和2的值**即可

    代码：

    - ```cpp
        #include <iostream>
        #include <algorithm>
        #define ll long long
        using namespace std;
        const ll mod = 1e9+7;//对这个数取余，操作均为ll 
        const ll N = 1e5+5;
        ll a[N], n, num[N];//num为该长度的火柴数 
        ll C(ll a, ll b)
        {//组合1和2就可以了 
        	return (b==1LL?a:a*(a-1LL)/2LL) %mod;//到处疯狂取mod 
        }
        int main()
        {
        	cin >> n;
        	ll maxlen=0;
        	for (int i=1; i<=n;i++)
        	{
        		cin>>a[i];
        		maxlen = max(a[i], maxlen);
        		num[a[i]]++;
        	}
        	ll ans = 0;//方案数 
        	//暴力枚举长度 
        	for (int i=2; i<=maxlen; i++)
        	{
        		ll temp;
        		//乘法原理--temp*(temp2)
        		if(num[i] >=2LL)
        		{
        			temp = C(num[i], 2LL) % mod;
        			//外层能挑出两根，才可以进入内循环挑另外两根组合成第三根 
        			for (int j=1; j<=i/2; j++) 
        			{
        				if (j ==i-j && num[j]>=2LL)ans+= temp * C(num[j], 2LL) % mod;//两根j凑一根i 
        				else if (j!=i-j && num[i-j]>=1LL && num[j]>=1LL)
        				{//&&num，有这长度的才能选吖 
        					ans += temp * C(num[j], 1LL)*C(num[i-j], 1LL) % mod;
        				}
        				ans %= mod;//有没有符合的火柴，对ans取余没有影响 
        			}
        		} 
        	}
        	cout << ans%mod << endl;
        	return 0;
        }
        ```

5. [P2241 统计方形（数据加强版） - 洛谷](https://www.luogu.com.cn/problem/P2241)

     分析：

     - 矩形数 = 长方形数 + 正方形数

     ~~自己的错误思路：~~

     - 固定左上角，枚举边长。显然自己都知道会超时（其实知道要用公式），且没有搞明白怎么不重不漏算个数

     思路1：

     - <font color =red>固定右下角（i，j），枚举右下角坐标</font>
     - 正方形数：==min（i，j）==
         - 画图推---很巧妙
     - 矩形数：==i * j== -----由矩形-正方形得到长方形数
         - 固定右下角，向左上方的其余格子延申，所以包括右下角自己所在格子，共能得到i*j个矩形
         - <img src="D:\Node-typora\note-picture\image-20250421162142495.png" alt="image-20250421162142495" style="zoom:33%;" />

     代码：

     - ```cpp
         #include <bits/stdc++.h>
         #define ll long long
         using namespace std;
         int n, m;
         ll ans1, ans2;//分别为正方形，矩形，  矩-正即为长方形 
         int main()
         {
         	scanf("%d %d", &n, &m);
         	for( int i=1; i<=n; i++) 
         	{
         		for (int j=1; j<=m; j++)
         		{//固定右下角，向左上方的其余格子延申 
         			ans1 += min(i, j);
         			ans2 += i * j;
         		}
         	}
         	printf("%lld %lld", ans1, ans2-ans1);
         	return 0;
         }
         ```

6. [P3392 涂条纹 - 洛谷](https://www.luogu.com.cn/problem/P3392)

     分析：

     - 暴力枚举+前缀和优化

     思路：

     - 旗帜要求涂成：W-B-R按顺序
         - 首先枚举白色W部分`i`：1~n-2行（至少留两）
         - 枚举蓝色B部分`j`：i+1~n-1行
         - 枚举红色R部分`k`：j+1~n
     - 前缀和优化：
         - 开三数组分别记录每一行涂成相应颜色的次数，进行自前缀前缀和
         - 再枚举的相应行间，通过前缀和计算行间涂色次数

     代码：

     - ```cpp
         #include <iostream>
         #include <algorithm>
         using namespace std;
         int n, m;
         char a[55][55];
         int w[55], b[55], r[55];
         int main()
         {
         	cin >> n >> m;
         	for (int i=1; i<=n; i++)
         	{
         		for (int j=1; j<=m; j++)
         		{
         			cin >> a[i][j];
         			if (a[i][j] != 'W')
         			{
         				w[i]++;//第i行涂成W的涂色次数 
         			}
         			if (a[i][j] != 'B') b[i]++;
         			if (a[i][j] != 'R') r[i]++;
         		}//计算完整行再计算自前缀
         		w[i] += w[i-1];
         		b[i] += b[i-1];
         		r[i] += r[i-1];
         	}
         	//meiju
         	int ans = 25000, temp =0;
         	for (int i=1; i<=n-2; i++) {
         		for (int j=i+1; j<=n-1; j++){
         			temp += w[i] - w[0];
         			temp += b[j] - b[i];
         			temp += r[n] - r[j];
         			ans = min(ans, temp);
         			temp = 0;
         		}
         	}
         	cout << ans << endl;
         	return 0;
         }
         ```

7. [P1088 NOIP 2004 普及组\] 火星人 - 洛谷](https://www.luogu.com.cn/problem/P1088)

     分析：

     - 分析题意发现：这是将123……所有**全排列**按照==字典序==排序，得到全排列表示的1、2、3数字

     思路：

     -  借助<algorithm>中的`next_permutation`函数
         - 和sort相似的使用方式：给定一数组的区间下标，**对当前区间所有元素形成的全排列**进行按<font color=red>下一个全排列进行排序</font>

     代码：

     - ```cpp
         #include <iostream>
         #include <algorithm>
         using namespace std;
         
         int n, m, a[10005];
         int main()
         {
         	cin >> n >> m;
         	for (int i=0; i<n; i++)cin >> a[i];
         	
         	for (int i=0; i<m; i++)
         	{
         		next_permutation(a, a+n);
         	}
         	for (int i=0; i<n; i++) cout << a[i] << ' ';
         	
         	cout << endl;
         	return 0;
         }
         ```

     感悟：

     - 强大的STL库

8. [P1217 USACO1.5\] 回文质数 Prime Palindromes - 洛谷](https://www.luogu.com.cn/problem/P1217)

     分析：

     - 观察数据范围最高到一亿10^8^

     - 最暴力的解法，从a到b一一枚举，同时满足回文(反转一下判回文)和质数，则输出

         - 时间复杂度就是O(n*(isprime))

     - 所以需要进行剪枝

         - 1.**重要结论**：<font color=red>偶数位数的回文数一定不是质数，因为其一定能被11整除(有余数11)</font>

             > 173371 / 11 = 15761

         - 2.唯一是偶数的质数为2，所以往后所有偶数都不是质数

     思路：

     - 跳过所有偶数位数的数
     - 将起始点a定为奇数，每次+=2，只枚举奇数

     代码：

     - ```cpp
         #include <iostream>
         using namespace std;
         int a, b;
         bool ishuiwen(int x)
         {
         	int t=0, n=x;
         	while (n>0)
         	{
         		t = t * 10 + n%10;
         		n/= 10;
         	}
         	return t == x;
         }
         bool isprime(int x)
         {
         	for (int i=2; i*i <=x; i++)
         	{
         		if (x%i == 0)return false;
         	}
         	return true;
         }
         int main()
         {
         	cin >> a >> b;
         	if (a%2==0)a++;//从奇数开始
         	for (int i=a; i<=b; i+=2){
         	///*
         		if (i>11 && i<=99){//11是质数，是唯一的偶数位数的回文数
         			i = 101-2;continue;
         		}
         		if (i>1000 && i<=9999){
         			i = 10001-2; continue;//加上之后就不会在这个区间 
         		}
         		if (i>100000 && i<=999999){
         			i = 1000001-2; continue;
         		}
         		if (i>10000000 && i<=99999999){
         			i = 100000001 - 2; continue;
         		}
         		//*/
         		if (ishuiwen(i) && isprime(i))
         		{
         			cout << i << '\n';
         		}
         	}
         	return 0;
         }
         ```

     感悟：

     - 实现跳过枚举偶数位数的数，错误思想

         - ```cpp
             if (i>11 && i<=99){
                 i = i + 90 - 4;
                 continue;
             }
             if (i>1000 && i<=9999){
                 i = i + 9000 -2;
                 continue;//加上之后就不会在这个区间 
             }
             //.。。。。
             ```

             > 以上是错误思想代码。
             >
             > 当起始点在这个偶数位数数的范围，通过加上给定数实现跳过操作，会使得一些**回文质数被跳过判断**
             >
             > - eg：a=20， i=20属于偶数位数范围，i= i+90-4后，在i += 2后，i = 108。就跳过了回文质数101

         - 所以**直接跳到下一个奇数位数的第一个数**

9. 















## 贪心

1. [P3817 小A的糖果 - 洛谷](https://www.luogu.com.cn/problem/P3817)

    分析：

    - 这题需要对第一个盒子的糖果进行判断，需要保证其糖果数<=x
    - <font color=red>每次相邻组合只吃右边</font>，就能保证相邻组合糖果数一定能通过吃右边而满足<=x

    思路：

    - 相邻盒子组合糖果数，吃右边会对左右都产生影响

    代码：

    - ```cpp
        #include <iostream>
        #define ll long long 
        using namespace std;
        ll n, x, a[100005], ans;
        int main()
        {
        	cin >> n >> x;
        	for (int i=1; i<=n;i++) cin >> a[i];//1~n
            //注意：这题需要对第一个盒子的糖果进行判断，需要保证其糖果数<=x
            //这样再每次相邻组合只吃右边，就能保证相邻组合糖果数一定能通过吃右边而满足<=x
            //a[0]:0颗,不要单独判断
        	for (int i=1; i<=n; i++)
        	{
        		if (a[i] + a[i-1] > x)
        		{//就吃右边那盒糖果 ---既能影响左边，又能影响下一组的右边
        			ans += a[i]  + a[i-1] - x;//吃掉的糖果数
        			a[i] = x - a[i-1];
        		}
        	}
        	cout << ans << endl;
        	return 0;
        }
        ```

1. [P2240 【深基12.例1】部分背包问题 - 洛谷](https://www.luogu.com.cn/problem/P2240)

    分析：按价值比排序

    思路：
    
    - 特别情况：考虑到背包承重T<u>大于所有</u>金币堆重量
      
        ```cpp
        while (t != 0 && i <= n) // 背包容量t特别能装，i>n时都装完了
        if (t >= ans[i].m)
        ```
    
3. [P1106 删数问题 - 洛谷](https://www.luogu.com.cn/problem/P1106)

    分析：

    - 删数问题可以逆向地转化为---------选数问题
    - 要求删数后，剩下最小数，则可以每次选择**当前轮**最小数---贪心
    - 注意去除前导0，特殊的只有一个0，直接输出0

    思路：

    - 删k位数，即选数保留`len(n)-k`位数
        - 从左往右选数保留
        - 注意：第一个数可以选0，最后输出前要进行去除前导0处理
    - 选数当前轮：
        - 从上一次选数位置的**下一个位置开始选**，在**len(n) - 待选数量cnt**的位置前（含该位置）必须选出区间最小数的位置----（否则无法保证删够k位数）

    代码：

    - ```cpp
        #include <iostream>
        #include <string>
        #include <vector>
        using namespace std;
        string n;
        int k;
        vector<char> ans;
        int main()
        {
        	cin >>n;cin >> k;
        	//保留len(n) -k位数----逆向 
        	//从左往右选数保留
        	//第一数不能选0！！！！ -----------------------此思想错误，0可以做开头并且忽略掉 --------最后去除前导0即可 
        	int cnt = n.size()-k;
        	int pos = -1;
        	while (cnt)
        	{
        		int temp = 257;//超过字符最大值 
        		for (int i=pos+1; i<=n.size()-cnt; i++)
        		{//在0~size-cnt必须要选出第一位（否则无法达到删除k位数的题目要求），以此类推 
        			if (n[i] < temp ){	
        				temp = n[i];pos = i;
        			}
        		}
        		ans.push_back(n[pos]);
        		cnt--;//选出了一个数 
        	}
        	//去除前导0
        	int start=0;//别忘了ans是字符类型 
        	while (ans[start] == '0'&& ans.size()>1) start++;
        	for (int i=start; i<ans.size(); i++) cout << ans[i];
        	cout << endl;
        	return 0;
        }
        ```

    感悟：

    - 思想的**逆向处理**，灵活应变
    - **边界条件**处理的重要性--------一定要考虑到，**不能全ac等于没ac**（bushi）
    - 字符与整型间-----asc||码的微妙关系----'0'=48,  A=65, a = 97

4. 





## 二分

1. [P2249 【深基13.例1】查找 - 洛谷](https://www.luogu.com.cn/problem/P2249)

    分析：给定输入时单调不减的，自然能想到使用二分查找O(logn)

    思路：

    - 找到第一个要求数字的位置。可以使用`lower_bound( )`

    手搓二分注意点：

    - 猜测位置nums[mid] == 目标值，需要继续往左找试图找出可能存在的相同数字的第一个位置
        - 这个二分过程是保证了，如果存在相同数字，**左端l**就是其<u>第一次出现的位置</u>

    代码：

    - ```cpp
        #include <iostream>
        #include <cstdio>
        using namespace std;
        const int N = 1e6+5;
        int numb[N];
        int n, m;
        int main()		
        {	
            scanf("%d %d", &n, &m);
            for (int i=1;i<=n; i++)scanf("%d", &numb[i]);
            while (m--)
            {
                int l = 1, r = n;
                int t;scanf("%d", &t);
                int temp = -1;
                while (l <= r)
                {
                    int mid = l + (r-l)/2;
                    //mid=1+(r-1)/2是一种防止l+r溢出整数范围的一种写法，数学上等价(l+r)/2
        //            if (t == numb[mid])
        //            {
        //                // 注意：返回第一次出现的编号-----单独往前找，会超时！！
        //                while(mid-1 > 0)
        //                {
        //                    if(numb[mid-1] == t)mid--;
        //                    else  break; 
        //                }
        //                printf("%d ", mid); flag = 0;break;
        //             }
        			 
                    if (t <= numb[mid]) //等于也去左边找，找相同的第一个位置
        			{				//---不用担心会不会左边界卡住相同的数，自身模拟下就知道了 
        				r = mid-1;	
        				if (t == numb[mid])temp = mid;//时间复杂度 O(mlogn)
        			} 										
                     else l = mid+1;//猜小了 
                }
                if (numb[l] == t)printf("%d ", l);
                else  printf("%d ", temp);//始终没找到，temp为-1 
            }
            return 0;
        }
        ```

2. [P1102 A-B 数对 - 洛谷](https://www.luogu.com.cn/problem/P1102)

    分析：

    - 转换思想-----A-B = C----> A - C = B  <-->  A = B+C
    - 将原数组所有数组元素减去C，得到B，再计算原数组中B的个数，累加即为答案

    思路1：**转换式子+map映射**

    - 本质就是找到原数组中有多少个等于`元素+C`的元素
    - <font color=red>就是哈希表的思想</font>

    核心代码：

    - ```cpp
        for (int i=1;i <=n;i++){
            scanf("%lld", &a[i]);mp[a[i]]++;
            //a[i] -= c;
        }
        for (int i=1; i<=n; i++)ans += mp[a[i] + c];
        ```

    思路2：二分思想

    - 

3. [P1873 COCI 2011/2012 #5\] EKO / 砍树 - 洛谷](https://www.luogu.com.cn/problem/P1873)

    分析：

    - 二分答案。答案为砍树机设定高度[0, maxtreelen]
    - 注意：
        - 不需要单独对对刚好调到这个高度，所得木材==m。我们对>=m的情况都往右“抬高”砍树机
        - 存在情况此时木材已经够了(>=m)，但是抬高一点就不够木材了。
            - 这种情况退出二分循环时，右区间为答案，左区间-1也为答案。所以结果需要再mid一次，此时mid就为猜测的正确答案

    思路：二分答案-----退出循环时的mid并非最终答案

    代码：

    - ```cpp
        #include <iostream>
        #define ll long long
        const int N = 1e6+10;
        using namespace std;
        int n, h[N];
        ll m;
        int main()
        {
        	cin >> n >>m;
        	int maxlen = 0;
        	for (int i=1;i<=n; i++){
        		cin >> h[i];
        		if (h[i]>maxlen)maxlen = h[i];
        	}
        	int l = 0, r=maxlen, mid;
        	while (l <= r)
        	{
        		mid = (l+r)/2;
        		ll sum = 0;
        		for (int i=1;i <=n; i++){
        			h[i]>mid?sum+=h[i]-mid: 0;
        		}
        		if (sum > m)l = mid+1;
        		else r = mid -1;  //if (sum < m)r = mid-1;
        		//else break;
        	}
        	mid = (l+r)/2;
        	cout << mid << endl;//等价输出l-1|r
        	return 0;
        }
        ```

    感悟：

    - 二分答案对最后答案的取值的分析和把握（l、mid、r的理解）
    - 所以脑海中对题目的意思要清晰，借助草稿完成题目的答案求解

4. [P1678 烦恼的高考志愿 - 洛谷](https://www.luogu.com.cn/problem/P1678)

    分析及思路：

    - 对每所学校的分数线sort一下
    - 依次根据学生估分成绩进行二分查询到最可能保证不满意度最小的两所学校L、R
        - **注意：这里可能只有一所**。两种情况
            - 估分<u>小于所有</u>学校的分数线（F5），只有分数最低的学校L可选可计算不满意度
            - 估分<u>大于所有</u>学校的分数线（orz），只有分数最高的学校R能保证不满意度最小
        - **还要注意**：估分与分数线差距过大时，最后计算的不满意度和可能会爆`int`，**所以要开`long long`**
    - 当有两所可能学校选择时，因为无法确定那所不满意度最低，需要作差比较

    代码：

    - ```cpp
        #include <iostream>
        #include <cmath>
        #include <algorithm>
        using namespace std;
        const int N = 1e5+5;
        int m, n;//m学校、m学生
        int a[N], b[N];//b为估分 
        long long  ans;//----------***估分与分数线差距过大，会爆int，所以用ll来存 
        int main()
        {
        	//本题使用二分查找找到估分左右区间 
        	//但不知道与哪个差距小，所以都要作差比较取最小
        	 cin >> m >> n;
        	 for (int i=1; i<=m; i++)cin >> a[i];
        	 for (int i=1; i<=n; i++)cin >> b[i];
        	 sort(a+1, a+1+m);
        	 while (n)//O(nlogm)
        	 {
        	 	int l=1, r=m, mid;
        	 	while (l <= r)
        	 	{
        	 		mid = l + (r-l)/2;
        	 		if (a[mid] > b[n])r = mid-1;
        	 		else l = mid +1;
        		}
        		if (b[n]-a[r] >= a[l]-b[n] && r != 0 && l != m+1){
        			ans += a[l]-b[n];
        		}
        		else if (r == 0)ans+= a[l]-b[n];//最左边没学校
        		else if (l == m+1) ans += b[n]-a[r];//右没 
        		else ans += b[n]-a[r];
        		n--;
        	 }
        	 cout << ans << endl;
        	 return 0;
        }
        ```

    感悟：

    - 对数据的观察能力，选择适当的数据类型存储，`int`和`long long`的选择
    - 二分查找最终得到的是<u>1.结果</u>还是<u>2.结果区间</u>，<u>3.左右端点是否合法</u>都要仔细斟酌

5. [P1163 银行贷款 - 洛谷](https://www.luogu.com.cn/problem/P1163)

    分析及思路：

    - 财经知识，`loan = (last)loan * (1+rate) - pay`-------利率按月累计
    - 利滚利，导致最终还不上loan，需要设定一个合适的rate，保证在month内还完loan
    - 所以此题就是取二分答案rate，注意是浮点型double，采用另一种我不常写的二分写法

    注意：

    - 数据保证答案不超过 300.0%，使用小数double，二分范围为：(0, >3)
    - rate设定，最后剩余贷款不会等于0，只会趋于0，此时会死循环，咋整？
        - 当二分范围`r-l < 0.0001`时，猜测的答案rate就一点能满足题目要求，此时跳出循环
            - 而不是用`mid < 0.0001`，这样仍然会假死循环
            - 或者使用剩余贷款loan（temp）趋于0来跳出循环------会**TLE**哒

    代码：

    - ```cpp
        #include <iostream>
        #include <cstdio>
        using namespace std;
        int loan, pay, month;
        //财经知识假设利率按月累计：loan = loan*(1+rate) - pay 
        //loan*(1+rate)：这就是贷款加利息的过程，利滚利。
        //当利率设定过高，会导致无法在指定month内还完甚至利滚利永远还不完 
        //所以本题是二分答案题，二分利率rate, 使month后loan趋近于0 
        int main()
        {
        	cin >> loan >> pay >> month;
        	//数据保证答案不超过 300.0%,所以r可以为大于3的数 
        	double l=0, r=5, mid;//第一次二分分数 
        	while (l < r)
        	{
        		mid = (l+r)/2;
        		if (r-l < 0.0001)break;//-----------temp还款趋近于0的另一个角度就是答案rate设定也趋近于0 
        		double temp = loan;
        		for (int i=1; i<=month; i++) temp = temp*(1+mid) - pay;
        		if (temp < 0) l = mid;
        		//else if (temp < 0.000001 || temp ==0)break;//趋近于0或等于0--------TLE
        		else if (temp > 0) //rate设大了
        			r = mid;
        		else break;//temp == 0
        	}
        	printf("%.1f\n", mid*100);//*100,百分制
        	return 0; 
        }
        ```

    感悟：

    - 二分的另一二分区间的写法，以及本蒟蒻第一次二分分数

        - ```cpp
            double l = 0, r = max_possible, mid;
            while (l < r)//另一种我常写的写法：l <= r
            {
                mid = (l + r) / 2;
                if (....)r = mid;//----r = mid - 1;
                else l = mid;//--------l = mid + 1;
            }
            cout << mid << endl;//---------跳出循环，答案：r = l-1, mid = r;
            ```

6. 





## 线性表

1. [P3613 【深基15.例2】寄包柜 - 洛谷](https://www.luogu.com.cn/problem/P3613)

    分析：

    - 很简单使用二维数组存第i个柜子里第j个格子，但是显然1e5 * 1e5大小的数组会爆栈

        - ```cpp
            //就像这样
            struct node{
            	ll box[N];
            }a[N]; 
            ```

    - 怎样避免**MLE**。使用老大哥vector？

        - 虽说也是二维，但至少节省了许多不必要的空间
        - 因为下标的问题。时间复杂度最高会来到1e7 * 1e5，显然会**TLE**

    - 最后就要想到==STL中的将军----map==

    思路：

    - 使用map让结构体i，j与格子中存放的物品建立映射

    - ```cpp
        map<pair<int, int>, int> mp; //访问方式：mp[{i, j}] //{i, j}表示pair二维下标
        ```

    代码：

    - ```cpp
        #include <iostream>
        #include <map>
        #define ll long long
        using namespace std;
        //二维数组会爆内存 
        int n, q, i, j;
        ll k;
        map<pair<int, int>, ll> mp;
        int main()
        {
        	cin >> n >>  q;
        	int flag;
        	while (q--)
        	{
        		cin >> flag;
        		if (flag == 1)
        		{//cun
        			cin >> i >> j >> k;
        			mp[{i, j} ]= k;
        		}
        		else{
        			cin >> i >> j;cout << mp[{i, j}] << endl;
        		}
        	}
        	cout << endl;
        	return 0;
        }
        ```
    
    感悟：
    
    - 花时间对map的了解







## 递推&递归

递推与递归是算法设计中两种核心方法，尽管它们都涉及重复计算，但在实现逻辑、效率和应用场景上有显著差异。以下是两者的详细对比：

---

**1. 定义与核心思想**
• 递推（迭代）：  

  从已知的初始条件出发，通过逐步推导（如循环结构）依次计算后续状态，直至得到最终结果。递推是==自底向上==的，例如计算斐波那契数列时，从第1项和第2项开始逐步推导到第n项。

• 递归：  

  将问题分解为更小的同类子问题，通过函数自我调用解决这些子问题，最终合并结果。递归是==自顶向下==的，例如在计算阶乘时，先分解为n*(n-1)!，直到达到终止条件（如n=1）。

---

**2. 实现方式的差异**
• ==递推通常使用循环结构（如`for`或`while`）==，通过变量迭代更新中间结果。例如斐波那契数列的递推实现仅需几个变量存储前两项的值，无需函数调用。


• 递归依赖于函数自我调用，每次调用会生成新的栈帧。例如树的前序遍历递归代码简洁，但需要处理递归终止条件和参数传递。


---

**3. 计算效率对比**
• 递推效率更高：  

  递推通过循环直接计算，避免了递归的函数调用开销和栈空间占用，时间复杂度和空间复杂度通常更低。例如<u>斐波那契数列的递推时间复杂度为O(n)，而纯递归实现为O(2^n)</u>。

• 递归可能重复计算：  

  递归在分解问题时可能重复计算相同子问题（如斐波那契数列的递归解法），需通过记忆化（Memoization）优化。

---

**4. 适用场景**
• 递推的典型应用：  

  • 数列计算（如斐波那契数列、阶乘）。

  • 动态规划问题（如背包问题），通过递推公式填充状态表。

  • 线性问题或需要高效计算的场景（如数值模拟）。


• 递归的典型应用：  

  • 树/图的遍历（如深度优先搜索DFS）。

  • 分治算法（如归并排序、快速排序）。

  • 回溯问题（如八皇后、组合排列）。


---

**5. 优缺点总结**
| 特性       | 递推                         | 递归                             |
| ---------- | ---------------------------- | -------------------------------- |
| 代码复杂度 | 逻辑直观，但需设计状态变量   | 代码简洁，符合问题自然分解逻辑   |
| 内存占用   | 通常更低（仅需存储中间变量） | 栈空间消耗大，递归过深易导致溢出 |
| 调试难度   | 易于跟踪变量变化             | 调试复杂（需跟踪多层调用栈）     |

---

**6. 实际案例对比**
以斐波那契数列为例：
• 递推实现（时间复杂度O(n)，空间O(1)）：

  ```python
  def fib_iter(n):	#暂时看不懂
      a, b = 0, 1
      for _ in range(n):
          a, b = b, a + b
      return a
  ```

• 递归实现（时间复杂度O(2^n)，需记忆化优化）：

  ```python
  memo = {}
  def fib_rec(n):
      if n <= 1: return n
      if n not in memo:
          memo[n] = fib_rec(n-1) + fib_rec(n-2)
      return memo[n]
  ```

---

**总结**
选择递推或递归需根据问题特性权衡：  
• 优先递推：对性能要求高、问题规模大、需避免栈溢出的场景。  

• 优先递归：问题自然适合分解为子问题（如树结构）、代码可读性优先的场景。  

实际开发中，递归可通过记忆化或尾递归优化提升效率，而递推在动态规划等场景中更具优势。



例题：

1. [P1255 数楼梯 - 洛谷](https://www.luogu.com.cn/problem/P1255)

    分析：

    - 大问题—>子问题
    - 递推公式
        - 设f(n)为n阶台阶的走法，则它会是由f(n-1)一步或者f(n-2)两步达到的
        - <font color=red>f(n) = f(n - 1) + f(n - 2) </font> ----跟**==斐波拉契数列==**似的
    - 找终止条件
        - f(1)  =1, f(2) = 2

    思路：

    - 转换公式，找到以上分析得出的递推公式
        - 理解：走到n级台阶前是在n-1级或者n-2级台阶处的走法数是独立的，所以二者相加便可得到n级台阶处的走法
    - 斐波那契数列的计算到应用**==高精度算法==**-----**第5000项**：数量级为10^1044^
        - **`int`类型**：仅支持到第46项。
        - **`long long`类型**：支持到第92项。
            - <font color=red>二维数组模拟高精度开int类型就可以了，避免==MLE==</font>
        - **超过范围时**：需借助高精度算法或库
    - 方法1：递推
    - 方法2：递归
    
    代码：
    
    - ```cpp
        #include <iostream>
        using namespace std;
        int n;
        //二维数组模拟高精度开int类型就可以了，避免MLE
        int f[5005][5005];//f[n][高精度表示]级台阶的走法数 
        int len;//，倒序输出f[n][ ] 
        void high_add(int x)
        {
        	//这种判断方式，如果中途恰好两数在同一位数为0，就会提前终止 
        	//for (int i = 1; f[x-1][i] != 0 || f[x-2][i]!=0; i++)
        	//i <= 5000直接把时间复杂度拉满，牺牲时间 
        	for (int i = 1; i <= 5000; i++)
        	{
        		f[x][i] += f[x-1][i] + f[x-2][i];//从个位往后加 
        		if(f[x][i] >= 10) 
        		{
        			f[x][i] -= 10;
        			f[x][i+1]++;
        		}
        		len = i+1;
        	}
        	while (f[x][len] == 0) len--;	//去除前导0
        }
        int main()
        {
        	cin >> n;
        	f[1][1] = 1, f[2][1] = 2;
        	for (int i= 3;i <=n; i++)
        	{
        		high_add(i);
        		//for (int j = len; j>0; j--) cout << f[i][j];
        		//cout << ' ';
        	}
        	//输出
        	if (n ==1 || n==2)
        	{
        		cout << f[n][1];//也可以将len初始化为1；
        	}else
        	{
        		for (int i = len; i>0; i--) cout << f[n][i];//使用下标i哈这里
        	 } 
        	cout << endl;return 0;
        }
        ```
        
    - ```cpp
        int a, b, c;
        for (int i=1; i<=n; i++)
        {
            c = a + b;
            a = b;
            b = c;	//递推的转换。本题将a，b，c转换为高精度的a，b，c即可全ac
        }
        ```
    
2. 



## 动态规划

### 动态规划的引入

1. [P1216 IOI 1994\] 数字三角形 Number Triangles - 洛谷](https://www.luogu.com.cn/problem/P1216)

    分析：

    - 自己：一维数组+自上而下的解法
    - 其他多数题解：二维数组+自下而上

    代码：

    - ```cpp
        #include <iostream>
        #include <algorithm> 
        using namespace std;
        int r, dp[1005], last[1005], ans;
        //dp[i]：表示当前行到达第i个位置的最大权值 （由上至下） ----------可以去掉last数组，合为一个二维dp数组，即dp[i][j]表示该行该位置
        int main()
        {
        	cin >> r;
        	int n = 1, t;
        	while (r--)
        	{
        		for (int i=1; i<=n; i++)
        		{
        			cin >> t;
        			dp[i] = max(t+last[i-1], t+last[i]);//比较i、i-1，使用+=也行 
        		}
        		for (int i=1;i<=n;i++)last[i] = dp[i];//不要在同一循环赋值，会影响下一个值
        		n++;
        	}
        	for (int i=1; i<n; i++)dp[i]>ans?ans = dp[i]:0;
        	cout << ans << endl;
        	return 0;
        }
        ```

    感悟：

2. [P2196  NOIP 1996 提高组\] 挖地雷 - 洛谷](https://www.luogu.com.cn/problem/P2196)

    分析：

    - 暴力搜索dfs
    - dp转移

    思路：

    - 涂涂画画：<img src="D:\Node-typora\note-picture\7089b53bd558c4edb4918b4b7616ebe7.jpg" alt="7089b53bd558c4edb4918b4b7616ebe7" style="zoom:25%;" />

    - 设计状态数组？

        - <font color = red>dp[i]：表示<u>从i开始挖</u>的最多地雷数</font>？<u>以i结尾</u>的最多地雷数？
        - 这么一想，从i开始挖更符合

    - 从后往前？从前往后？

        - ~~从前往后：如果当前与下一个有连通，dp[i] += lei[i+1]，仔细一想涉及回溯，不是dp的作风，pass掉~~

        - 从后往前：

            - 从最后个地窖节点开始挖，最多就是它本身的地雷数，dp[n] = lei[n]

                >即初始化

            - <font color = red>递减枚举开始挖的地窖编号：验证**其后面所有**编号比当前地窖编号大的地窖**是否有连通**</font>

                - 有的话就可以走过去，dp[i] = dp[i+1] + lei[i]
                - 有多个的话，就要比较一下取max。dp[i+1] + lei[i] > dp[i]?
                - 一个都没，dp[i] = lei[i]

    - 状态转移方程就找到啦

    其他问题处理：

    > 1.输出从某节点开始挖最多的地雷数，同时还要求**输出挖地雷的行进路径**

    - 开一个nexti[]数组(变量名不为next，避免冲突)：
        - `nexti[i] = j`：表示当前节点`i`朝下一个节点`j`行进可以使`dp[i]`最多。
        - `nexti[i] = 0`：表示当前节点`i`没有可行进路径，好日子到头了 
    - <img src="D:\Node-typora\note-picture\image-20250526160034259.png" alt="image-20250526160034259" style="zoom: 67%;" />

    >2.如何表示地窖与地窖之间的连接关系？

    - 脑子孬，想不到直接用**二维数组**嘛

    代码：

    - ```cpp
        #include <iostream>
        using namespace std;
        int n, dp[21], lei[21], nexti[21];
        int link[21][21];//i到j是否连通,1：连通 
        int main()
        {
        	cin >> n;
        	for (int i=1; i<=n; i++)cin >> lei[i];
        	for (int i=1; i<n; i++){
        		for (int j=i+1; j<=n; j++)cin >> link[i][j];
        	}
        	dp[n] = lei[n];
        	int ansi = n;
        	for (int i=n-1; i>=1; i--)
        	{//枚举开始挖的节点 
        		dp[i] = lei[i];
        		for (int j=i+1; j<=n; j++)
        		{//枚举i节点之后所有可能行进的节点 
        			if (link[i][j] == 1 && dp[i]<lei[i] + dp[j])
        			{//(有多个就比较选出最优的)走过去 
        				dp[i] = lei[i] + dp[j];
        				nexti[i] = j;
        			}
        		}
        		if (dp[i] > dp[ansi])ansi = i;//找最优开始点 
        	}
        	int ti = ansi;
        	while (ti != 0)
        	{//打印路径 
        		cout << ti << ' ';
        		ti = nexti[ti];
        	}
        	cout << '\n';
        	cout << dp[ansi] << endl;
        	return 0;
        }
        ```

    感悟：

3. [P1434 SHOI2002\] 滑雪 - 洛谷](https://www.luogu.com.cn/problem/P1434)

    分析：

    - 题意是啥？啥是最长滑坡的长度？

        >语文一生之敌，读个题目半天不知道他要问我啥？啥是最长滑坡的长度，这个样例解释就不能清楚一点嘛，照顾一下我这个飞屋
        >
        >- 最长滑坡长度：从最优高度向上下左右四个方向满足高低更低可以滑下去的路径的个数，即长度
        >
        >    >这个样例答案输出25就是25-24-23-22-21-...-1，共25个，所以最长滑坡长度为25

    - 求解最优解问题？贪心？记忆化搜索（dp的一种递归实现方式罢了）？dp？

        - 采用记忆化搜索（基于递归实现），是动态规划的备忘录写法

    思路：

    - 枚举每个点作为起点（两个for），向4个方向滑动（递归搜索，滑动过去继续搜索），直至不能滑动为止
    - 滑动过去长度+1，取max返回最大长度
    - 搜索过程很清楚会**有路径被重复计算，所以可以备忘录**，以该点为起点的最大滑坡长度计算过就直接用就好了
    - ![IMG_20250527_132344](D:\Node-typora\note-picture\IMG_20250527_132344.jpg)
    
    代码：
    
    - ```cpp
        #include <iostream>
        #include <algorithm>
        using namespace std;
        int r, c, maxlen, note[105][105];//备忘录初始化全0,没有记 
        int zone[105][105];//区域 
        int dx[4] = {-1, 1, 0, 0 };//上下左右 
        int dy[4] = {0, 0, -1, 1};
        int dfs(int x, int y)
        {
        	if (note[x][y]!=0)return note[x][y];//计算过？
        	int res = 1;//待返回结果----如果都不能滑动，自身也是一个长度 
        	int xx, yy;
        	for (int i=0; i<4; i++)
        	{
        		xx = x+dx[i];
        		yy = y+dy[i];
        		if (xx>0 && xx<=r && yy>0 && yy <=c && zone[x][y] > zone[xx][yy])
        		{//不越界，并且高度更低 
        			res = max(res, dfs(xx, yy)+1);
        			//dfs最终返回结果就是以下一个点为起点能滑的最长滑坡距离。
        			//这里+1表示：当前点滑动过去，结果就是当前点为起点的最长滑坡长度 
        		}
        	}
        	note[x][y] = res;
        	return res;
        }
        int main()
        {
        	cin >> r >> c;
        	for (int i=1; i<=r; i++)
        	{
        		for (int j=1; j<=c; j++)
        		{
        			cin >> zone[i][j];
        		}
        	}
        	for (int i=1; i<=r; i++)
        	{
        		for (int j=1; j<=c; j++)
        		{
        			maxlen = max(maxlen, dfs(i, j));
        		}
        	}
        	cout << maxlen << endl;
        	return 0;
        }
        ```
    
    感悟：
    
    - 理解题意，动态规划的备忘录写法，即待记忆化的搜索也是最优解的选择
    
4. 



### 线性动态规划

1. [P1020  NOIP 1999 提高组\] 导弹拦截 - 洛谷](https://www.luogu.com.cn/problem/P1020)

    分析：

    - 本题有两问：

        - 1.同使用一套系统最多导弹拦截数

        - 2.拦截所有导弹最少需要的拦截系统数

            > **这两问独立的。**并不是说一定是在一套系统拦截最多导弹后在分析，而是全局分析最少需要几套系统
            >
            > 这里导弹依次飞来，所以每一个导弹飞过来都要及时进行拦截 

    - 

















## 基础数学问题

1. [P1143 进制转换 - 洛谷](https://www.luogu.com.cn/problem/P1143)

    分析：先转十进制。n--->10---->m

    思路：

    - 字符串存n进制数

    - n转十进制从低位lowbit开始，==求和 bitnumb * n^bits^==

        - 所以要<font color=red>倒着遍历字符串target，指数bits也从idx0开始（从左往右）</font>

        - vector存答案，字符型数组ans-----采用acsll码存储

            - A：65、**0：48**

            - ```cpp
                if(tar[i] < 65) x = temp%m + 48;//重要！！
                ```

    - 除基取余倒着读别忘了，倒着输出ans

    代码：

    - ```cpp
        #include <iostream>
        #include <string>
        #include <cmath>	//使用pow（base,n） 
        #include <vector>
        #define ll long long
        using namespace std;
        int n, m;
        string tar;
        vector<char> ans;
        ///十进制做跳板 
        int main()
        {
        	cin >> n >> tar >> m;//(tar)n --> (tar)m
        	ll temp = 0;
        	//倒着转，从低位开始 ----*****
        	int idx = 0;
        	for (int i=tar.size()-1; i >=0; i--)
        	{
        		if (tar[i] >= 65){
        			temp += (tar[i] - 'A' +10) * pow(n, idx);
        		}
        		else	
                    temp += (tar[i] - '0') * pow(n, idx);
        		idx++;
        	}
        	//十进制temp，转m进制，注意》10，使用A~F
        	//0:48,A:65
        	while (temp !=0 ) 
        	{
        		//除基取余 
        		char x;
        		if (temp %m >=10)
        		{
        			x = 'A' + temp%m -10;
        			ans.push_back(x);
        		}else
        		{
        			x = temp%m + 48;
        			ans.push_back(x);
        		}
        		temp /= m;
        	}
        	//倒着读 
        	for (int i=ans.size()-1; i>=0; i--){
        		cout << ans[i];
        	}
        	cout << endl;
        	return 0;
        }
        ```

2. [P2822 NOIP 2016 提高组\] 组合数问题 - 洛谷](https://www.luogu.com.cn/problem/P2822)

    分析：

    - <img src="D:\Node-typora\note-picture\image-20250427155336236.png" alt="image-20250427155336236" style="zoom:50%;" />本质：第n行是二项式(1+1)^n-1^的展开式

    - 对于本题需要借助==杨辉三角==掌握的组合数递推公式，即组合数：<font color=red>$C(n,r) = C(n-1, r-1) + C(n-1, r)$</font>

        - 通过两层for循环，计算出所有组合数，组合数对k取余==0，即为k的倍数，改行答案+1

    - 注意：两层for循环，不能放在while(t--)循环询问中，为避免超时，可以借助==二维前缀和==存储答案

        - <font color=blue>二维前缀和存答案原理</font>：ans[i] [j]的前缀和区间都是n、m分别取1 ~ i、1 ~ j的答案数之和，即满足要求的(i, j)对

        - 疑惑：为啥i、j不用从0开始取？

            规定取0的组合数为1，提示数据2<= k <= 21，所以取0必定不符合要求,同时防止数组越界

            **另外要对取0的组合数单独初始化为1**：`for(int i=0;i<=2000;i++)c[i] [0] = 1;`

    思路：

    - 使用long long存储组合数求得的杨辉三角递推公式
    - 维护二维答案前缀和ans数组
        - <u>对k取余==0</u>并且&& <u>j<=i</u>。答案+1
    - 询问输入n、m直接输出ans数组
        - <font color=red>注意</font>：输入的n、m虽说n>=m的组合数才有意义，但它就是<u>会输入m>n的情况</u>，所以需要遍历2e3*2e3次，计算**所有的c[i] [j]**

    代码：

    - ```cpp
        #include <iostream>
        #define int long long
        using namespace std;
        int t, k, n, m;
        int ans[2005][2005];
        int c[2005][2005];
        signed main()
        {
        	cin >> t >> k;
        	//重要
        	for(int i=0; i<=2000; i++) {c[i][0] = 1;//单独处理杨辉三角全为1的左边的边
        	}
        	//在while询问外，初始化所有
        	for (int i=1; i<=2000; i++){
        		for (int j=1; j<=2000; j++){
        			c[i][j] = (c[i-1][j] + c[i-1][j-1]) % k;//避免超过存储范围*****
        			if (c[i][j] == 0 && j <= i) ans[i][j]++;
        			ans[i][j] = ans[i][j-1] + ans[i-1][j] -ans[i-1][j-1] + ans[i][j];//不放在if条件中，这是没执行一次都需要维护更新的二维前缀和
        		}
        	}
        	while (t--) 
        	{
        		cin >> n >> m;
        		cout << ans[n][m] << endl;
        	}
        	return 0;
        }
        ```

    - ```cpp
        //没有认真审题，错误思想代码：
        for (int i=1; i<=2000; i++){
            for (int j=1; j<=i; j++) {
                c[i][j] = (c[i-1][j] + c[i-1][j-1]) % k;
                if (c[i][j] == 0)ans[i][j]++;	 //&& j <= i) ans[i][j]++;
                ans[i][j] = ans[i][j-1] + ans[i-1][j] -ans[i-1][j-1] + ans[i][j];
            }//不可以跳过j>i的所有情况
        }
        ```

    感悟：

    - 取余的妙用，避免超过存储范围
    - 按照规定办事，0! = 1，全部初始化好，一个都不能落下！
    - 二维前缀和每个循环都要进行维护，符合条件在进行相应的判断

3. [P1100 高低位交换 - 洛谷](https://www.luogu.com.cn/problem/P1100)

    分析：

    - 第一眼想到了直接**模拟解法**
    - 糕手还要想到**位运算解法**

    思路：

    - 结合`unsighed`、位运算、`swap()`

    代码：

    - ```cpp
        #include <iostream>
        #include <cmath>
        #include <vector>	// 这里使用vector下标从0开始存，而我的本意是从1开始 
        #define int long long
        using namespace std;
        int a[33];//存储二进位----一开始错误使用了vector
        signed main()
        {
        	int n ; 
        	cin >> n;
        	//十进制转2
        	int len = 0;
        	while (n != 0)
        	{
        		a[len+1] = n%2;//这里已经实现了倒着读 
        		n /= 2;
        		len++;
        	}
        	//倒着读
        //	int t[len+1];
        //	for (int i=1; i<=len; i++){
        //		t[i] = a[len-i+1];
        //	}
        //	for (int i=1;i <=len;i++)a[i] = t[i];
        	//补0 ----全局，可省 
        //	while (len < 32){
        //		a.push_back(0);len++; 
        //	}
        	//交换------也可以使用swap函数 
        	int temp[33] = {0};
        	for (int i=1; i<=16; i++){
        		temp[i] = a[16+i];
        		temp[16+i] = a[i];
        	}
        	for (int i =1; i<=32; i++)a[i] = temp[i];
        	//2转10
        	int ans = 0;
        	for (int i=0; i<32; i++){
        		ans += a[i+1] * pow(2, i);
        	}
        	cout << ans << endl;
        	return 0;
        }
        ```
        
    - ```cpp
        #include <iostream>
        using namespace std;
        int main()
        {
            unsigned int n;cin >> n;
            cout << (n<<16) + (n>>16) << endl;
            return 0;
        }
        ```
    
    感悟：
    
    - vector数组是固定**从0下标**开始存数的，不同于普通数组**可0可1**
    - 除基取余倒着读如何正确在数组中存储----搞清楚，不要糊涂了
    - swap、pow等好用的函数
    
4. [P3913 车的攻击 - 洛谷](https://www.luogu.com.cn/problem/P3913)

    分析：

    - 暴力模拟肯定超时
    - 画图
    - 可以很直观地推出公式：ans = **num(r) * n + num(c) * (n - num(r))**

    思路：

    - 1.借助**stl中的`set`来去重**，得到所有k个车所在的行列数
        - set的insert，时间复杂度O(logN),N为set中元素个数
        - <font color=red>此题并不需要排序，**只需要去重**功能，所以可以采用`unordered_set.insert()`，时间复杂度**O(1)**</font>
            - 引入头文件`<unordered_set>`
    - 2.使用排序后，**手动去重**得到行列数

    代码：

    - ```cpp
        for (int i=1; i<=k ;i++){
           	cin >> r >> c;
            setr.insert(r);//使用insert 
            setc.insert(c);
        }//O(klogN)---->会超时
        //改用unordered_set容器的插入，复杂度O(k)，就ac了
        ```

    感悟：

    - 处理时间复杂度的魅力~

5. [P3601 签到题 - 洛谷](https://www.luogu.com.cn/problem/P3601)

    前置知识：

    - ==欧拉函数==：求给定正整数n，在<u>小于等于n</u>中，有多少个与n**互质**[^1]？
        - eg：$$\phi(8)$$:给定正整数8，在1~8中，多少个数与8互质？有2、3、5、7，所以Φ(8) = 4
    - 质数筛：埃式、欧拉线性筛等

    分析：

    - 









# 省一题单

1. [P3131 USACO16JAN\] Subsequences Summing to Sevens S - 洛谷](https://www.luogu.com.cn/problem/P3131)

    分析：

    - 自己一看题想到的菜鸟思路：枚举左右区间，前缀和减减减，时间复杂度不敢想，高得可怕

    - 改变思路：

        - 先直接求 mod 7 意义下的前缀和，然后只要看看余数的重复就可以了

            > 定理：**若两个数相减 (mod 7=0) ，那么这两个数 mod 7 的余数一定相同**

        - 只要求出**相同的一个余数**<u>第一次出现</u>到<u>最后一次出现</u>之间的长度即是最长长度

    思路：

    - 由分析得：先对所有数前缀和处理
    - **区间和**：sum[r] - sum[l - 1]，当其mod 7 == 0，根据**定理**等价于sum[r] mod 7 == sum[l - 1] mod 7 （两余数相等）
        - 本题所求最长mod 7 = 0的区间，即相同的余数在序列中第一次出现到最后一次出现的距离，为最长区间长度--------<font color=red>完成问题求解的转化</font>
    - 相同的余数可能是0~6，所以先对经前缀和处理后序列每个元素再mod 7
        - 统计0~6这7个余数首尾出现的距离，再从中取最长的
    - 得到最大连续奶牛组

    代码：

    - ```cpp
        #include <iostream>
        #include <algorithm>
        using namespace std;
        int n, id[50005], sumid[50005];//先对id前缀和处理，再对前缀和mod 7
        int pos[7] = {-1, -1, -1, -1, -1, -1, -1};//初始化为-1（不能用0，0是余数之一），表示没有记录 
        int main()
        {
        	cin >> n;
        	for (int i=1; i<=n; i++)
        	{
        		cin >> id[i];
        		sumid[i] = sumid[i-1] + id[i];
        		sumid[i] %= 7;
        	}
        	int maxans = 0;
        	for (int i=0; i<=n; i++)//需要从0开始，前缀和的计算也是r-(l-1) 
        	{
        		//记录该余数首次出现位置 （其中余数为0的首个位置容易搞错，其实是不存数据的下标0）
        		if (pos[sumid[i]] == -1) 
        		{
        			pos[sumid[i]] = i;//pos[0] = 0,0的首个位置
        		}
        		else{
        			//再次出现
        			maxans = max(maxans, i-pos[sumid[i]]);//前缀和相减得区间长度，不用+1
        		}
        	}
        	cout << maxans << endl;
        	return 0;
        }
        ```

    感悟：

    - 计算时间复杂度
    - 运用定理降低复杂度，巧妙解题

2. [P1101 单词方阵 - 洛谷](https://www.luogu.com.cn/problem/P1101)

    分析：

    - 难点也就是我的痛点：题目描述的是啥意思啊？？？
    - 好的，看看讲解，原来是要我朝八个方向搜索匹配`yizhong`这个单词字符，完全匹配在输出是显示出来，没匹配上的打`*`

    代码：

    - ```cpp
        #include <iostream>
        using namespace std;
        char mat[105][105];
        int n, flag[105][195];//标记是否完全匹配上，1匹配上用于最后的输出
        int dx[8] = {-1, -1, 0, 1, 1, 1, 0, -1};//顺时针 
        int dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};
        char match[8] = "izhong";//0~5
        int main()
        {
        	cin >> n;
        	for (int i=0; i<n; i++) 	cin >> mat[i];//一行一行读入
        	///cout << mat[0][0] << endl;
        	//时间复杂度O(48*n^2) 
        	for (int i=0; i<n; i++)
        	{
        		for (int j=0; j<n; j++)
        		{
        			if (mat[i][j] == 'y')
        			{////对当前点（i，j）遍历8个方向，找izhong
        				for (int k=0; k<8; k++)
        				{//枚举方向 
        					int xx = i, yy = j, cnt= 0;
        					for (int m=0; m<6; m++)
        					{//该方向匹配次数 
        						xx += dx[k];
        						yy += dy[k];
        						if (xx>=0 && xx<n && yy>=0 && yy<n && mat[xx][yy] == match[m]) cnt++;
        						else break;
        					}
        					if (cnt == 6)
        					{//完全匹配才打标记，不要先打标记没匹配上再取消标记，因为同一个字母可能是多个单词公用的 
        						while(cnt)
        						{
        							flag[xx][yy] = 1;
        							xx -= dx[k];//回退 
        							yy -= dy[k];
        							cnt--;
        						}
        						flag[xx][yy] = 1;//起始枚举点（i，j） 别忘了
        					}
        				}
        			}
        		}
        	}
        	for (int i=0; i<n; i++)
        	{
        		for (int j=0; j<n; j++)
        		{
        			if (flag[i][j])cout << mat[i][j];
        			else cout << '*';
        		}
        		cout << '\n';
        	}
        	return 0;
        }
        ```

    感悟：

    - 语文素养，理解题意
    - 调试能力

3. [P1162 填涂颜色 - 洛谷](https://www.luogu.com.cn/problem/P1162)

    分析：

    - 我的错误思想：去找哪些是被包围的0

        > 时间复杂度会很高，跑不出来

    - 利用bfs搜索连续的区块的特性，找到所有外部的0，将其标记出来。这样由1及由1包围的0就组成了一个没有被标记的“孤岛”，输出是将孤岛的0输出成2即可

    思路：

    - 外部的0并不一定是连续的，用bfs搜不完全。怎么解决？
        - 在整个区间套上一层0，则外部的0就变成了连续的，使用bfs标记，“孤岛浮现”
    - <img src="D:\Node-typora\note-picture\image-20250531165621835.png" alt="image-20250531165621835" style="zoom:33%;" />
    - 原区间：`1~n`；套一层后--->`0~n+1`

    代码：

    - ```cpp
        ```

    感悟：

    - 对bfs借助队列进行层级搜索的回顾，而不是把bfs写成dfs了还不知道问题出在了哪
    - 其实用dfs也行🐕

4. [P9241 蓝桥杯 2023 省 B\] 飞机降落 - 洛谷](https://www.luogu.com.cn/problem/P9241)

    分析：

    - 读完题意就是要合理安排飞机的降落次序使所有飞机成功降落
        - 怎么安排？
    - 看一下评测数据范围很小，第一时间就要猜到这大概就是道暴力模拟题
        - 算算时间复杂度：O(t * n!)，足够过了

    思路：

    - 第i架飞机允许降落时间【Ti， Ti+Di】

        > 常识要让飞机尽可能早的降落，为后续飞机降落腾出仅有的跑道

    - 第i架飞机最早什么时间降落？<font color=red>**max(Ti,   Time+Ltime)**</font>

        > 1.第i-1飞机完全降落完成后，第i架飞机还没到，此时Ti时刻降落
        >
        > 2.第i架飞机已经到了，但第i-1飞机还没完全降落完成
        >
        > **Time~i-1~、L~i-1~**：指上一架飞机实际安排的降落时间，和落地滑行时间

    - 安排不合理：当Time+Ltime > Ti+Di，第i架飞机油耗尽未能降落，返回

    - 无论怎么安排都会不合理，无法保证所有飞机成功降落，输出`NO`

    - 有一种安排保证所有飞机成功降落，**打上标记**，结束输出`YES`

    **Time~i-1~、L~i-1~**的问题所在：

    - Time表示上一架飞机落地时间，当**L[i-1]并不表示上一架飞机落地滑行时间**
        所以这里同样要用`Ltime`来记录上一架飞机落地滑行时间
        - 当然可以将Time+Ltime**整合成一个变量`Time`**表示上一架飞机完成降落的时间

    代码：

    - ```cpp
        #include <iostream>
        #include <algorithm>
        #include <cstring>
        using namespace std;
        int n, T[15], D[15], L[15], flag;
        int Time, Ltime; //t1, t2;//上一架飞机安排的降落时间,本架降落时间 
        int t;//测试样例
        int vis[15];//访问数组，表示第i架飞机已经安排降落 
        //安排函数 
        void arr(int k)
        {
        	if (k > n)
        	{//安排到第k架 
        		//cout << "YES" << endl;
        		flag = 1;
        		return;//可以进行剪枝操作，但这里时间复杂度够过
        	}
        	for (int i=1; i<=n; i++)
        	{
        		if (vis[i] == 0 && Time+Ltime <= T[i]+D[i])
        		{//可安排 
        			int t1 = Time;//不能设全局变量，会在后续安排中改变此刻存取的值 
        			int t2 = Ltime;
        			Time = max(Time+Ltime, T[i]);
        			Ltime = L[i];
        			vis[i] = 1;
        			arr(k+1);//安排下一架 
        			vis[i] = 0;
        			Time = t1;//回溯 
        			Ltime = t2;
        		}
        	}
        }
        int main()
        {
        	cin >> t;
        	while (t--)
        	{
        		memset(vis, 0, sizeof(vis));//这种多数据样例，一般都要重置公用变量 
        		flag = 0; //重置 
        		cin >> n;
        		for (int i=1; i<=n; i++) cin >> T[i] >> D[i] >> L[i];
        		arr(1);
        		if (flag)cout << "YES" << endl;
        		else cout << "NO" << endl;
        	}
        	return 0;
        }
        ```

    ==感悟==：

    - 对自己定义的**变量和数组表示的含义的理解**，本题中Ltime表示上一架，不等于L[i-1]表示的含义
    - 用于递归回溯的临时变量，不可以设成全局，否则会在递归的过程发生改变，不在是递归树特定位置想要保存的值
    - 对于多个测试样例的输入的题目，使用while(t--)内，需要对每一组样例公用的变量数组进行重置

5. [P2040 打开所有的灯 - 洛谷](https://www.luogu.com.cn/problem/P2040)

    分析：

    - 一道搜索题。dfs、bfs都可以。

    - <font color=red>每盏灯只能开关一次</font>

        > 口头证：对于一盏灯无论是自身开关还是受影响开关，同一盏灯开关俩次**对自身和周围的状态等于没变**

    - 本道题dfs时间复杂度（夺嫂？）能过

    - 还能对每盏灯的状态进行状态压缩，即用二进制表示

    思路dfs：

    - 暴力深搜每一盏灯

    代码：

    - ```cpp
        #include <iostream>
        #include <algorithm>
        using namespace std;
        
        int vis[10][10], a[10][10];//每个灯只能按一次 
        int ans = 10;//初始化为10，因为最多不会超过10次 
        int dx[5]= {0,-1, 1, 0, 0}, dy[5] = {0, 0, 0, -1, 1};
        bool check()
        {
        	for (int i=1; i<=3; i++) 
        	{
        		for (int j=1; j<=3; j++)
        		{
        			if (a[i][j] == 0)return false;
        		}
        	}
        	return true;
        }
        void change(int x, int y)
        {
        	for (int i=0; i<5; i++)
        	{
        		int xx = x + dx[i];
        		int yy = y + dy[i];//xx,yy不会越界 
        		a[xx][yy] = 1 - a[xx][yy];//1-0=1,1-1=1,实现了反转 
        	}
        }
        void dfs(int step) 
        {
        	//if(step > ans) return;//剪枝 
        	if (check())
        	{//每次都检查一下是否达111111111 
        		ans = min(ans, step);
        	}
        	//暴力深搜，访问所有可能，但只能访问一次 
        	for (int i=1; i<=3; i++) 
        	{
        		for (int j=1; j<=3; j++)
        		{
        			if(vis[i][j] == 0) 
        			{
        				vis[i][j] = 1;
        				change(i, j);//改变自己的灯和周围灯的状态
        				dfs(step+1) ;
        				vis[i][j] = 0;
        				change(i, j);//在改变一次就还原了 
        			}
        		}
        	}
        	
        }
        int main()
        {
        	for (int i=1; i<=3; i++) 
        	{
        		for (int j=1; j<=3; j++)
        		{
        			cin >> a[i][j];
        		}
        	}
        	dfs(0);//深搜步数 ---先检查后改变灯的状态，ans=min(step)
        	cout << ans << endl; 
        	return 0;
        }
        ```

6. [P1019 NOIP 2000 提高组\] 单词接龙 - 洛谷](https://www.luogu.com.cn/problem/P1019)

    分析：

    - 数据范围比较小，可以试着暴搜
    - 处理单词间的接龙部分
        - 相邻的两部分不能存在包含关系[^2]

    思路：

    - substr函数截取字符

        > substr(截取地址， 截取长度)

    代码：

    - ```cpp
        #include <iostream>
        #include <string> 
        using namespace std;
        
        int n, ans, vis[25];//只能用两次 
        string s[25];
        char a;
        string islink(string x, string y)
        {
        	int len1 = x.size(), len2 = y.size();
        	for (int i=1; i<len1 && i<len2; i++)
        	{
        		if (x.substr(len1-i, i) == y.substr(0, i))
        		{
        			return x.substr(0, len1-i) + y;
        		}
        	}
        	return "0";//接龙失败 
        }
        void dfs(string sss)
        {
        	if (sss.size() > ans)ans = sss.size();//最长接龙字符长度
        	
        	for (int i=0; i<n; i++) 
        	{
        		if (vis[i] != 2 )
        		{
        			//连接---需要知道匹配接龙的位置，所以可以在判断是否可接龙上的函数里实现接龙 
        			string linked = islink(sss, s[i]);
        			if (linked != "0")
        			{
        				vis[i]++;
        				dfs(linked);
        				vis[i]--;
        			}
        		}
        	}
        }
        int main()
        {
        	cin >> n;
        	for (int i=0; i<n; i++)cin >> s[i];
        	cin >> a;//开头
        	for (int i=0; i<n; i++)
        	{
        		if (s[i][0] == a)
        		{
        			vis[i]++;
        			dfs(s[i]);
        			vis[i]--;
        		}
        	}
        	cout << ans << endl;
        	return 0;
        }
        ```

7. [B4158 BCSP-X 2024 12 月小学高年级组\] 质数补全 - 洛谷](https://www.luogu.com.cn/problem/B4158)

    分析：

    代码：

    - ```cpp
        
        #include <bits/stdc++.h>
        using namespace std;
        const int N = 1e7;
        int isprime[N], flag, minans;//最小符合质数 
        string s;
        int vis[10];//位数是否计算过 
        void aishai()
        {
        	isprime[0] = isprime[1] = 1;
        	isprime[2] = 0;//2是质数
        	for(int i=2;i <N; i++) {
        		if (isprime[i]==0){
        			for (int j=i*2; j<N; j+=i){
                        //质数的倍数 
        				isprime[j] = 1;//筛掉 
        }}}}
        
        void dfs(int depth, int x)
        {
        	if (depth > s.size()){
        		if (isprime[x]==0){
        			minans = min(minans, x);
        			flag = 1; 
        		}
        		return;
        	}
        	
        	for(int i=0; i<s.size(); i++)
        	{
        		if (s[i] != '*' && vis[i] == 0)
        		{//只有打*才搜0~9 
        			depth++;
        			vis[i] = 1;//(s[i]-48)字符转int 
        			x += (s[i]-48) * pow(10, s.size()-i-1);
        			//加入这里是最后一个位置，需要再这里就判断
        			//因为打*位置不在最后一位值，到不了上面的判断
        			if (depth > s.size())
        			{
        				if (isprime[x]==0)
        				{
        					minans = min(minans, x);
        					flag = 1; 
        				}
        				return;
        			} 
        		}
        		else if (i != depth-1)continue; 
        		else {//0~9填在打*位置要配对上i=depth-1 
        			for (int j=0; j<=9; j++) 
        			{
        				vis[i] = 1;
        				x += j * pow(10, s.size()-i-1);
        				dfs(depth+1, x);
        				vis[i] = 0;
        				x -= j * pow(10, s.size()-i-1);
        				memset(vis+i+1, 0, sizeof(vis[0])*(10-i-1));//回退到打星前 
        			}
        		}
        	}
        	
        }
        int main()
        {
        	//预处理--埃式筛法
        	aishai();
        	// -----
        	int t; cin >> t;
        	while (t--)
        	{
        		cin >> s;
        		flag = 0;minans = N;
        		memset(vis, 0, sizeof(vis));
        		dfs(1, 0);
        		if (flag == 0)cout << -1 << endl;
        		else cout << minans << endl;
        	}
        	return 0;
        }
        ```

    感悟：

    - 小学生都不如，奥林匹克竞赛真是超前学习，超常智商
    - 

8. [P4310 绝世好题 - 洛谷](https://www.luogu.com.cn/problem/P4310)

    分析：

    - 子序列满足条件：bi & bi-1 !=0，即子序列相邻两项相与不为0，求最长子序列长度

    - 这里需要注意的一点是：从a中选取出来的子序列，各元素不要求相邻

        > 这里就会发现这跟==最长上升子序列==一米一样，只是条件从**上升**改为了**按位与**

        - 按照之前最长上升子序列的这种简单的dp做法，会有TLE样例

            > 数据范围达1e5，最长上升子序列时间复杂度O(n^2^)

    - 考虑优化时间

    思路：

    - <img src="D:\Node-typora\note-picture\IMG_20250611_171121.jpg" alt="IMG_20250611_171121" style="zoom: 25%;" />

    代码：

    - ```cpp
        #include <iostream>
        #include <algorithm>
        using namespace std;
        const int N = 1e5+5;
        
        void solve1()
        {
        	int n, a[N] = {0};
        	int dp[N] = {0};//以a[i]结尾的相与&子序列最长长度 
        	cin >> n;
        	for (int i=1; i<=n; i++)
        	{
        		cin >> a[i];dp[i] = 1;
        	}
        	//if (4&4 == 0)cout << "herw" ;
        	int ans = 0;
        	for (int i=1; i<=n; i++)
        	{
        		for (int j=1; j<i; j++)
        		{
        			if (a[j] & a[i])
        			{
        				dp[i] = max(dp[i], dp[j] + 1);
        			}
        		}
        		ans = max(ans, dp[i]);
        	}
        	//for (int i=1;i <=n; i++) cout << dp[i] << '\n';
        	cout << ans << endl;
        }
        
        int dp[33][N] = {0}; //ai的范围不超过整数范围，32位足够
        
        void solve2()
        {
        	//solve1的O(n^2)需要优化，这里借助位运算 
        	int n, a[N] = {0};
        	//int dp[33][N] = {0};//不可以设成局部变量，爆栈了都，还想运行呢
        	cin >> n;
        	for (int i=1; i<=n; i++)cin >> a[i];
        	int ans = 0;
        	for (int i=1; i<=n; i++)
        	{//枚举列 
        		
        		//-------找i-1列，即前一列符合条件的最长长度k 
        		int k = 0;
        		for (int j=0; j<32; j++)//-----------------------------debug 
        		{
        			if (a[i] & (1<<j))k = max(k, dp[j][i-1]);
        				//dp[j][i] = max(dp[j][i], dp[j][i-1]+1);//j发生改变接不上，也每找到最长长度 
        		}
        		//----------------------------
        		for (int j=0; j<32; j++)
        		{//枚举行
        			if (a[i] & (1<<j))dp[j][i] = k+1;//接在符合条件的最长长度上 
        			else dp[j][i] = dp[j][i-1];//直接继承
        			
        			ans = max(ans, dp[j][i]);
        		}
        	}
        	cout << ans << endl;
        }
        
        
        void solve3()
        {
        	int n, a[N] = {0}, dpp[33] = {0};
        	cin >> n;
        	for (int i=1; i<=n; i++)cin >> a[i];
        	int ans = 0;
        	for (int i=1; i<=n; i++)
        	{//枚举列 ------------优化成dpp[33]因为每次计算i只用到了 i-1，所以不需要开列，只保留行就行了 
        		int k = 0;
        		for (int j=0; j<32; j++)
        			if (a[i] & (1<<j))k = max(k, dpp[j]); 
        			
        		for (int j=0; j<32; j++)
        		{//枚举行
        			if (a[i] & (1<<j))dpp[j] = k+1; 
        			//else dp[j][i] = dp[j][i-1];//否则该行的值不用变 
        			
        			ans = max(ans, dpp[j]);
        		}
        	}
        	cout << ans << endl;
        }
        int main()
        {
        	//solve1();
        	//solve2();	//时间优化，借助位运算 
        				//dp[j][i]：表示前i个元素的j行的*最长与序列*的最长长度 
        				//与*最长上升子序列*还是有所不同，并不是以a[i]结尾 
        	
        	solve3(); 	//可进行空间优化，dp[j]：计算i只用到了i-1，故可以只保留行号j 
        				
        	return 0;
        }
        ```

    感悟：

9. [P3743 小鸟的设备 - 洛谷](https://www.luogu.com.cn/problem/P3743)

    分析：

    - 题目要求求最长使用时间， 即答案。最值问题？二分？dp？贪心？

        - 这题使用**二分(分数)答案，加贪心处理**

            > 答案是使用时间，是分数double类型

        - 若可以无限使用，输出-1。

            > 需要特判一下：
            >
            > - <font color=red>当所有设备的**消耗能量速度总和**还是小于等于充电器的**充电速度**，输出-1。</font>

    思路：

    - 二分时间，一开始可以整大点，确保涵盖所有数据范围
    - 跳出二分循环条件：
        - 因为是二分double类型，**二分时间的左右区间足够小**即可跳出
    - check函数的实现：
        - 利用贪心，充电器可以提供p*time的能量
            - 1.设备本身的能量 > 该时间内的消耗能量，就不给它充电
            - 2.否则就需要给它充电
        - 返回结果是充电器提供的能量是否够给它们充电
            - 够，返回1。继续扩大时间，l = mid
            - 不够，返回0。需要缩小时间，r = mid

    代码：

    - ```cpp
        #include <iostream> 
        using namespace std;
        const int N = 1e5+5;
        double n, p, a[N], b[N];//分数级，半秒也行 
        bool check(double time)
        {
        	double B = time * p;//充电器最多提供的能量 
        	for (int i=1; i<=n; i++)
        	{
        		if (time*a[i] <= b[i])continue;
        		else{
        			B = B -(time*a[i] - b[i]);
        		}
        	}
        	if (B >= 0)return true;
        	else return false;
        }
        int main()
        {
        	cin >> n >> p;
        	double sum = 0;
        	for (int i=1; i<=n; i++)
        	{
        		cin >> a[i] >> b[i];
        		sum += a[i];
        	}
        	if (sum <= p)
        	{
        		cout << -1 << endl;return 0;
        	}
        
        	double l = 0, r = 1e20, mid;//r足够大，保证覆盖所有数据
        	while (l < r)
        	{
        		if (r -l < 1e-5)break;//足够小，保证该区间答案正确
        		mid = (l+r)/2;
        		if (check(mid))l = mid;
        		else r = mid;
        	}
        	cout << mid << endl;
        	return 0;
        }
        ```

    感悟：

    - 二分分数答案的模板的应用
    - check函数的设计

10. [P1473 USACO2.3\] 零的数列 Zero Sum - 洛谷](https://www.luogu.com.cn/problem/P1473)

    分析：

    - 很容易想到用dfs去暴力搜索数字间的符号，找到n-1个符号就check一下

        > 暴搜函数的变量就是深度，即搜到的符号位置
        >
        > - 该位置可以填+、-、' '。不需要访问限制
        > - <font color=red>巧妙：用下标表示填入的符号</font>

    思路：

    - 用一个数组存各位置填入的符号，为了方便check，**在最前面填入一个`+`号**

        > eg: 1+2+3+4+5+6+7 改变后：**+**1+2+3+4+5+6+7

        - 将遍历的下标从1开始与数字1~N对齐（0下标不用），实现更便捷
        - 草稿上模拟check遍历过程，格外注意下标

    - **check函数**----本题的难点

        - 遍历存符号数组
            - 该位置是+、-：就去遍历该运算位置的**右运算对象**，如果下一个对象有空格，计算空格构成的一个右运算整体，再与当前对象+- 
            - 是' '空格：就直接跳过不管它，因为在这之前，已经计算过
        - 在最前面填入一个`+`号，就可以将计算原本第一间隔插入是空格的情况和其他部分的计算统一起来

    - 搭配存符号数组输出结果。

    代码：

    - ```cpp
        #include <iostream>
        #include <vector>
        using namespace std;
        int n; // vis[4];
        char a[3] = {' ', '+', '-'};//用数字0~2表示符号 
        vector<int> ve;
        bool check()
        {
        	int ans = 0; 
        	for (int i=1; i<=n; i++)
        	{
        		if (ve[i] == 0)continue;//是空格不管它，在这之前会经计算过 
        		
        		//当前填的不是空格，而是是+或-，就去找下一个对象，
        		//如果下一个对象有空格，计算空格构成的一个整体，再与当前对象+- 
        		//草稿纸上写清楚各自的下标 
        		int t = i; 
        		for (int j=i+1; j<=n; j++)
        		{ 
        			if (ve[j] == 0)
        				t = t*10 + j;
        			else break;//没有空格/结束空格构成的整体 
        			
        			//ve.push_back(t);根本不需要这么复杂的操作 
        		}
        		//回过头来与当前对象相加减
        		if(ve[i] == 1) ans += t;
        		else ans -= t;
        	}
        	return ans == 0;
        }
        void print()
        {
        	cout << 1;
        	for (int i=2; i<=n; i++) cout << a[ve[i]] << i;//下标存符号 
        	cout << endl;
        }
        void dfs(int depth)
        {
        	if (depth > n)//填2~n个空 
        	{//ve数组1~n个元素 
        		if (check())
        			print();
        		return;
        	}
        //	for (int i=0; i<n-1; i++)//根据depth，该空三个符号任选 
        	for (int j=0; j<3; j++)
        	{//直接数字表示填的符号
        		ve.push_back(j);
        		dfs(depth+1);
        		ve.pop_back();
        	}
        }
        int main()
        {
        	cin >> n;
        	ve.push_back(-1);//非法值0下标不用，从1开始存
        	ve.push_back(1);//在最前面填入+号 
        	dfs(2);//对齐，填第二个数字间隔位 
        	
        	return 0;
        }
        ```

    感悟：

    - 存在优先级的运算设计和计算方法
    -  ASCI I码的顺序：
        - <img src="D:\Node-typora\note-picture\image-20250612115841123.png" alt="image-20250612115841123" style="zoom:25%;" /><img src="D:\Node-typora\note-picture\image-20250612120254675.png" alt="image-20250612120254675" style="zoom: 33%;" />

11. 





# 灵茶题单

## 一、滑动窗口与双指针

### 1、定长滑动窗口

#### 我的思路模板

- ```c++
    //1. 维护区间和--扩、缩
    //2. check更新
    int n = nums.size(),l = 0, r = k-1;
    ll ans = 0, sum = 0;
    for (int i = l; i <= r; i++)
    	sum += nums[i];
    check();//先计算遍历k次，check一次
    for (r++; r < n; r++, l++)
    {
        //1. 维护窗口区间和扩、缩
        //2. check
    }
    return ans;
    ```

    - 左右窗口指针l、r----构成定长[L, R]窗口
        - 或者根据情景使用一个指针，构成一个定长窗口
    - 时间复杂度O(k + n-k) = O(n)
        - 先遍历k，check一次；后遍历剩下n-k，然后check

#### 定长滑窗套路

窗口**右端点在 i** 时，由于窗口长度为 k，所以窗口**左端点为 i−k+1**。

- 注意：<font color=red>这里枚举的`i`是窗口的右端点，无论窗口是什么样子。缩也是针对左端点</font>

总结成三步：入-更新-出。

1. 扩：下标为 i 的元素进入窗口，更新相关统计量。如果窗口左端点 i−k+1<0，则尚未形成第一个窗口，重复第一步。
2. 更新：更新答案。一般是更新最大值/最小值。
3. 缩：下标为 i−k+1 的元素离开窗口，更新相关统计量，为下一个循环做准备。以上三步适用于所有定长滑窗题目。

代码

- ```C++
    int ans = 0, sum = 0;
    for (int i = 0; i < s.size(); i++) { // 枚举窗口右端点 i
        // 1. 扩--右端点进入窗口
        //...
        //注意：判断是否形成窗口
        if (left < 0) { // 窗口大小不足 k，尚未形成第一个窗口
            continue;
        }
        //执行到这里就形成了窗口---我的模板是将这一步放在了另一个for循环
        
        // 2. 更新答案--------------可能需要**check**
        //check + 更新答案
        //...
    
        // 3. 缩--左端点离开窗口，为下一个循环做准备
        //...
    }
    return ans;
    ```

⚠️注意：

- 注意：此模板与我自己的区别在于，这里只用了**一个指针i**来维护定长窗口，一次遍历完n，是O(n)的
- 这里采用的是先缩，后扩。而我的模板是先扩在缩
- 所以：此模板优势---<font color=red>精炼</font>

---

#### 例题

1. [2841. 几乎唯一子数组的最大和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/description/)

    - 关键点：

        - ```c++
            unordered_map<int, int> mp;//映射表（哈希表），记录同一个数的数量
            ```

        - ```c++
            if (mp[nums[l]] == 0)
                mp.erase(nums[l]);//这个数没有了，不占子数组唯一个数
            ```

2. [1423. 可获得的最大点数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/description/)

    - 法一：逆向思维-滑动窗口

        > 拿走 k 张，剩下 n−k 张。这里 n 是 cardPoints 的长度。
        >
        > 由于拿走的点数和 + 剩下的点数和 = 所有点数和 = 常数，所以为了**最大化拿走的点数和**，**等价于最小化剩下的点数和（逆向）**。
        >
        > 由于只能从开头或末尾拿牌，所以最后剩下的牌必然是连续的。
        >
        > 至此，问题变成：
        >
        > <font color=red>计算长为 n−k 的连续子数组和的最小值。</font>
        > 这可以用定长滑动窗口解决。

        - 时空：O(n)、O(1)















[^1]:两个数公因数只有1
[^2]:你抱我我抱你都不行，两部分都要判断
