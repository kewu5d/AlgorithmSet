# 算法集训前导

目标：

1.学会做题---分析题意，寻找思路/确定算法，把思路转换成代码

2.巩固《数据结构》课程中的算法：

3.学习一些《数据结构》课程中没涉及到，但常用的算法。

常用算法：在算法比赛（不包括acm-XCPC，含蓝桥杯、pat甲级、cfp等），春/秋招笔试，考研复试(上机编程)中常出的算法（除北京、上海985机试难度大）

4.课程结束后，希望大家都可以独立的在oj上刷题练习

前置知识：

1.C/C++语言

2.《数据结构》

3.**C++标准模板库(STL)**中的常用容器和算法：见《算法笔记》第6章

- 会用就行

4.请大家自行注册 洛谷 和 leetcode 的账号，并自行学习这两个平台的使用方法。

- 洛谷：<u>普及、提高</u>、省选、NOI；==题单==

<font color = red>自身水平和有效刷题量成正比</font>

问题：

- 在刷题过程中，遇到不会的题怎么办？

  参考题解（不是照抄）。看题解中的思路，并学习思路，然后关掉题解，自己写代码。合理利用题解，不要养成抄题解的习惯！！！ 不要局限于一个题解，这个看不懂，就换一个看，总有一个适合你。

  - 中等难度：==5分钟没思路15分钟不完整20分钟还没敲，去看题解、视频、问al、学长==

- 整理**算法模版**

- 关于**解题报告**

	对于**错题**，可以整理解题报告：粘贴题目链接，简单描述题意，错误思路及错误原因总结，正确思路，AC代码，反思

- 课后独立完成课上例题后，还要刷题，同一个算法刷6-10题熟练掌握即可

Tips：

- 在自己的ide上写code，样例通过后cope一下，提交
- 提交返回结果
	- <img src="D:\Node-typora\note-picture\image-20250331162330684.png" alt="image-20250331162330684" style="zoom:50%;" />

题目时间限制：

- 计算<font color = red>时间复杂度</font>
- 使用c++语言可以将cincout换成printf、scanf（更快）

做题步骤：

1. 读题面，分析题意

2. 看示例（样例），分析样例

3. 看数据范围，确定时间复杂度（1s=10^8)

4. 找思路，写代码， 本地运行测试，提交

## 算法比赛评判机制

1. ACM赛制：实时反馈，有罚时
2. OI赛制：无实时反馈，以最后一次提交为准；按测试点部分给分。蓝桥杯
    - 所以蓝桥杯不会就写写暴力，骗点分
3. IOI赛制：实时反馈得分，无罚时，取最高分作为最终成绩。PTA



蓝桥杯

- ==必会==：前缀和、差分、找规律能力、进制转换、二分、双指针（前后+左右）、
- ds：链表、队列、栈、优先队列/堆、哈希表、单调栈/**队列**、二段单调队列、<u>树状数组（必考就压轴）、线段树/主席树</u>、
- 搜索：==dfs==、bfs、<u>二进制枚举</u>
- 动态规划：记忆化搜索、**线性dp**、**背包**（01、完全、多重）问题与背包计数/整数划分问题、<u>区间dp、树形dp</u>、数位dp、状压dp
- 数学：最大公约数、最小公倍数、唯一分解定理、素数、==素数筛法、快速幂==、费马小定理求逆元、
- 图论：dijkstra、floyd、kruskal、最小生成树、<u>拓扑排序（没考过）</u>
- 字符串：字符串哈希、kmp

国赛：

- <img src="D:\Node-typora\note-picture\image-20250501151906489.png" alt="image-20250501151906489" style="zoom: 25%;" />
- <img src="D:\Node-typora\note-picture\screenshot-1746966465553(1).png" style="zoom: 33%;" />
    - ==思维、线段树、二分、动态规划、dfs、最短路、并查集、优先队列==

- <img src="D:\Node-typora\note-picture\image-20250511203357763.png" alt="image-20250511203357763" style="zoom: 25%;" />



## 国赛考点聚焦

- <img src="D:\Node-typora\note-picture\image-20250511204812102.png" alt="image-20250511204812102" style="zoom:25%;" /><img src="D:\Node-typora\note-picture\image-20250511205415743.png" alt="image-20250511205415743" style="zoom: 25%;" />
- <img src="D:\Node-typora\note-picture\image-20250511205024755.png" alt="image-20250511205024755" style="zoom:50%;" />
    - <img src="D:\Node-typora\note-picture\image-20250511204027957.png" alt="image-20250511204027957" style="zoom:25%;" />
    - 




# 刷题小错误（技巧）

1. <img src="D:\Node-typora\note-picture\cce4b0131e50b13a5a74530e62395dbc.png" alt="img" style="zoom: 67%;" />

2. 二维数组逐一赋值：花括号嵌套**花**括号---🌸嵌🌸

3. scanf忘记**&**（取地址）

4. 低级各种循环、判断**条件错误、变量错误（写重）**，导致的死循环，无结果输出------`TLE`运行超时

    > bug常出在此

5. 不用费劲写**对拍**

6. `getchar()`用于清除<font color =red>输入缓冲区中的换行符</font>，没有处理输入缓冲区中的换行符，导致下一个读取的==字符==是换行符，导致数组存储错位。

  ```cpp
  #include <cstdio>
  scanf("%d %d", &k, &n);
  getchar();	//避免把换行符\n存进想存的位置
  scanf("%c", &blocks[1]);
  ```

6. 求**最小**值时，将其中一个变量实现定义成**假象最大可能**，<u>求最大值，反之</u>。

    - `<limits.h>`提供了基本数据类型的范围最值eg：INT_MAX

7. 任何一道题，都要注重对<font color=red>**边界**情况</font>的考量与设计

8. 使用**printf**对`long long`类型输出，应使用<font color=red>`%lld`格式符</font>，cout则不需要，**printf更规范，需要指定输出格式**

9. ```cpp
    int gap[100005] = { 0 };//将第一个元素初始化为0，其余元素默认为0，即全0
    ```

10. ==sort==(begin, end+1)排序的区间，一定要画图理解清楚明白，否则在OI赛制下，只会被给你打掉

    - 两个指针参数，==**左闭右开**==，所以<font color=red>往往加1</font>，确保对b~e的所有数据进行排序,默认升序

    - 可以降序`greater<typename>()`、自定义排序方式==cmp==-------<font color=blue>可以对结构体成员进行操作</font>

        ```cpp
        bool cmp(struct a, struct b){
            return a.val > b.val;//降序---****由大到小****
            //return a.val < b.val 前面的数小，后面的数大，所以是升序
        }
        sort(sturct1, struct2+n+1, cmp);
        ```
        
    - vector数组使用`begin()`，`end()`函数，而**不要写出**`ve+ve.size()`这种东西(普通数组用得)

    - 可直接对 `string` 内部的字符进行高效排序。支持默认升序、降序及自定义规则（如忽略大小写）。其核心依赖字符串的迭代器接口

11. 特殊情况特殊处理，编译出错`CE`时，第一时间想到：<font color=red>是否为边界条件没有处理到位</font>

12. ```cpp
      while (s.top() == poped[j] && s.empty() == 0)
      {
          //do somethings
          //错××××××××
          //此循环到栈空，是不可以查看栈顶元素的
      }
    ```

      - 因为编译器是<font color=red>从左往右编译</font>，可以利用==`&&`的短路==，将上面两代码调换一下顺序即可

13. 数组访问下标没有问题，问题出在了**变量名写重**了

14. **一定要画图，打草稿**，不要全凭大脑模拟，容易遗漏条件

15. <font color=red>并查集</font>合并后，根父节点的更新，一定是该节**点所在集合的==父节点的更新==**为另一个集合的父节点---才合并完成

       ```cpp
       f[fa] = f2b; f[fb] = f2a;//对-------也就是父节点的父节点
       //f[a] = f2b;f[b]=f2b;	//错误XXXXX
       ```

16. 在C语言中，**格式说明符** `%5d` 和 `%-5d` 用于控制整数的显示格式，具体含义如下：

     - **%5d**：
       - **5** 表示**最小字段（场）宽度**，即输出的整数**至少占据5个字符位置**。
           右对齐：如果整数不够宽，<u>左边会用空格补充</u>。
     - **%-5d**：
       - <font color=red>**-** 表示左对齐。</font>
       - **5** 表示最小字段宽度，整数左对齐，占据至少5个字符，<u>右边用空格补充</u>。
       - 示例：`printf("%-5d", 123);` 输出为 `123  `

     这两个说明符常用于控制输出格式，使结果对齐更整洁。

17. 对两个序列重新初始化

    - ==使用`C`的头文件`<cstring>`中包含的`memset( )`函数==
    
    - 函数原型
    
        ```c
        #include <cstring>  
        void* memset(void* s, int c, size_t n);  
        ```
    
        - `void* s`：指向要填充的内存区域的指针（数组名,就是地址）。
        - <font color=red>`int c`</font>：要**填充的字符值**。实际上，`c` 会被转换为 `unsigned char`，因此只考虑其低 8 位。
        - `size_t n`：要填充的字节数。------使用<font color=red>``sizeof( )``</font>
        
    - 示例1：
    
        - ```cpp
             int arr[5];  
             memset(arr, 0, sizeof(arr)); // 将所有元素初始化(重置)为0 
             ```
        
    - 示例2：
    
        - ```cpp
             memset(vis+i+1, 0, sizeof(vis));
             /*
             将数组vis中从索引位置 i+1 开始的连续内存区域清零（即每个字节设为 0）
             不是从0位置开始，这里存在一个问题，会导致RE
             因为第三个参数 sizeof(vis)：表示操作的内存大小（字节数）
             */
             ```
    
             - 越界风险：若 `i+1` 之后的**剩余空间不足** `sizeof(vis)` 字节，**会导致内存越界**（覆盖数组外的内存），引发未定义行为或程序崩溃
    
        - 解决方式：
    
             - 法1：**vis数组在题目要求的前提下，再开大一点**，多出来的空间闲置不用，防越界
                  	  不能万无一失，容易跳==RE==
    
             - 法2：推荐！
    
                  ```cpp
                  memset(vis+i+1, 0, sizeof(vis[0]) * (数组长度 - i - 1));  // 仅清零剩余元素
                  ```

18. 万能头文件`<bits/stdc++.h>`----适用于蓝桥杯、洛谷等oj

19. 答案四舍五入保留两位小数。<font color=red>`%.2f`</font>

20. 最后条件判断的时候，注意确定==变量的值是否已经改变==

       ```cpp
       //do something（对a、b值进行操作）
       //return a < b;//错误，a,b的值发生了改变
       ll aa = a, bb = b
       return aa < bb;
       ```

21. 使用这种方式，记录**偏移量**。枚举所有可能<img src="D:\Node-typora\note-picture\image-20250315153103016.png" alt="image-20250315153103016" style="zoom:50%;" />

22. ```cpp
     int check[100];
     //**初始化为0-----使用字符下标来存储（A23456789XJQK）AscNll码a为97（A65）,开10够用了
     check[A] = check[97];//一一对应，等价
    ```

     - 这里提一嘴：字符与整型的比较要通过ascnll码来联络，譬如字符'1' == 49

23. 在 C++ 中，`std::stoi` 函数的主要用途是将字符串转换为整数（`int` 类型）-----没咋用过

       ```cpp
       std::string str = "12345";//注意int的范围
       int num = std::stoi(str);  // 结果：num = 12345
       ```

24. CV过来的相同逻辑的代码，要仔细检查是否**需要改动的地方**和**修改过程没有同步而遗漏**的部分

25. `a[j] = x[i] - '0';`  //<font color=red>字符Ascnll码相减 得到整型数字</font>

26. cpp自带的==`swap()`函数==--交换俩数组各元素

            - 

27. 两数字字符串的比较当两数字字符串**长度相同时（前提）**，二者的比较（==字典序==）等同于整型之间的比较

     - 字典序

28. 科学计数法

       ```cpp
       float a = 123.456;  
       //使用scanf函数时，可以用 %f 或 %lf 来读取科学计数法的输入
       printf("%e\n", a); // 输出：1.234560e+02  
       //格式化输出：使用格式字符串如%.2e控制精度
       ```

29. <img src="D:\Node-typora\note-picture\uid2829740-20240405-1712331629856.png" alt="图片描述" style="zoom:50%;" />最大正数：约 **1.79e308**(1.79*10^308^)

30. ```cpp
     #include <cmath>  // 包含cmatch头文件  或  math.h
     double pow(double base, double exponent);  
    ```

31. **C/C++**

       - **全局数组**：一般可开到 `1e6` ~1e7级别（如 `int arr[1e6]`）。
           - 多维数组的空间更加要命
       - **局部数组**：受<u>栈内存</u>限制，通常不超过 `1e5` 级别（如 `int arr[1e5]`），否则可能导致栈溢出。需使用动态分配（如 `malloc` 或 `vector`）处理更大数据。
       - 不知道多长就用变长数组vector（也可以模拟高精度），注意倒着存数

32. 仔细检查数组所开大小，避免RE或者TLE

33. 在进行连续操作`while(t--)`时，每一次操作后，都需要将工具（数组、变量等）进行必要的初始化，为下一次操作做准备

34. 代码逻辑没问题，就要扣细节，例如：**for循环中变量下标有没有写错啊**

35. ```cpp
     #include <iostream>  
     #include <cstdlib>   // for std::abs(int)  
     #include <cmath>     // for std::abs(double) and std::fabs  
    ```

     - <font color=red>`abs()`函数：</font>计算绝对值

36. ```cpp
     const int N = 1e6 + 10;
     int l[N], r[N];	//挺好的一种写法
    ```

37. `<algorithm>`中max函数要求两数**类型相同**

38. C/C++中，逗号运算符`,`是一种特殊的运算符，其核心特性是**顺序执行表达式并返回最后一个表达式的值**

     - 优先级最低

     - ```cpp
         int a = (1, 2, 3); // a = 3
         double b = (1, 2.0); // b = 2.0
         ```

     - ```cpp
         int z = x++, y++, ++y; 
         // 等价于 (z = x++), y++, ++y; 而非 z = (x++, y++, ++y);
         ```
         
         - 常用于单行进行多行操作；

39. ```cpp
     //在C++中
     std::ios::sync_with_stdio(0);
     std::cin.tie(0);  // 解绑 cin 和 cout 的关联
     std::cout.tie(0); // 可选，进一步减少刷新
     //三者联立起来用，逗号分隔
     ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    ```

       这段代码主要用于优化输入输出流的性能，尤其在算法竞赛或需要处理大规模数据时至关重要。

        - 注意事项
            1. **<font color=red>禁止混用</font>C和C++的IO函数**
                **关闭同步后**，若混合使用`cin`/`cout`与`printf`/`scanf`，可能导致输出顺序混乱或数据未刷新。
            2. **调整换行符的使用**
                避免使用`cout << endl`，<font color =red>改用`cout << '\n'`</font>。因为`endl`会强制刷新缓冲区，而关闭同步后，自动刷新功能失效，频繁使用`endl`反而会降低效率
            3. **文件操作时的顺序**
                若需通过`freopen`重定向输入输出流，应将优化代码放在文件打开操作之后，否则可能因缓冲区未正确关联导致错误
        - 核心作用
            1. **关闭C++与C标准库的同步**
                `ios::sync_with_stdio(0)` 会关闭C++的输入输出流（`cin`/`cout`）与C标准库函数（如`printf`/`scanf`）的同步机制。默认情况下，这种同步保证了混合使用两种IO时的正确性，但也带来了性能损耗。关闭后，`cin`/`cout`的运行速度可显著提升，接近C标准库的效率
            2. **解除输入输出流的绑定**
        - 适用场景
            - 算法竞赛：处理大规模数据（如百万级输入）时，可大幅减少程序运行时间
            - 纯C++ IO环境：仅使用cin/cout且不需要与C标准库函数混用的情况

40. <font color=red>没思路就写个样例得出答案来模拟</font>，获取思路，**数学推导、思维、转脑筋**。注意细节

41. <font color=red>异或</font>：

      数学符号

       - 在数学逻辑运算中，异或的标准符号为 ==**⊕**（圆圈包围的加号==）。它表示两个命题的“排他性”关系，即当且仅当两个输入值不同时结果为真（1），否则为假（0）-----异或^即**不同则1**（或|：有1则1）

      计算机编程符号

       - 在编程语言中，异或运算通常使用`^`符号表示。例如：C语言中`a ^ b` 表示变量 `a` 和 `b` 的二进制按位异或

       符号的核心含义：异或运算的本质是<font color=red>“**无进位**二进制加法”</font>，其规则可概括为：

       - 相同为0，相异为1`1⊕1=0` `1⊕0=1`
       - 具有交换律、结合律、自反性等特性，例如 `a ⊕ b = b ⊕ a`，`a ⊕ 0 = a`

       应用场景示例

       1. 数据交换：通过异或运算无需临时变量即可交换两个数值（需注意变量地址不同）
       2. 加密与校验：利用异或的自反性实现简单加密或奇偶校验
       3. **算法设计**：如查找数组中仅出现奇数次数的数字

42. 在C++中，当使用`lower_bound`和`upper_bound`进行==二分查找O(logn)==时，如果找不到目标值，这两个函数会返回一个迭代器，指向插入目标值的位置。找到返回**第一个不小于**或**第一个大于**的位置的迭代器

       注意：对<u>已经排好序</u>的数组用。**是否从0下标开始**

       - `lower_bound`：<font color=red>返回第一个**不小于**目标值的数位置（所以目标值存在就返回它本身的位置）</font>
           - 当目标值**存在**时：`lower_bound`返回目标值的位置（迭代器），`upper_bound`返回<u>目标值后面</u>的位置
               - 由传进去的区间决定返回的位置
           - 如果目标值**不存在**于数组中，`lower_bound`和`upper_bound`都**返回插入目标值**的位置
               - 如果目标值小于数组的所有元素，返回数组的（插入）开始位置。
               - 如果目标值大于数组的所有元素，返回数组的（插入）末尾位置。
       - 如果`lower_bound`或`upper_bound`返回的迭代器等于`end()`，说明目标值大于数组的所有元素，未找到目标值

       常见用途：

       - 快速查找元素：可以用来判断一个元素是否存在在数组中。
       - 确定插入位置：可以用来在有序数组中找到合适的插入位置，以保持数组的有序性。

43. C++中的取模运算符`%` **仅支持整数类型（如int、long等）**，不能直接用于浮点数类型（如double、float）之间的运算

44. flag[11];//标记数组i位置元素是否被使用过

45. ```cpp
     if (num[i] >= 2ll) //检查是否 ≥2,明确这个2是long long类型
    ```

     - 这段代码通过 `2ll` or`2LL`明确数值类型，确保**大整数比较**时的安全性和准确性，适用于需要高精度或大范围整数操作的场景

46. `auto`

    - `auto`用于**变量声明**时，编译器会根据右边表达式的类型自动推断变量的类型。
    
        ```cpp
        auto a = 10;       // a的类型为int  
        auto b = 3.14f;    // b的类型为float  
        auto c = "hello";  // c的类型为const char*  
        ```
    
    - 在**遍历容器**时，使用`auto`可以让代码更简洁
    
        ```cpp
        #include <vector>  
        
        std::vector<int> vec = {1, 2, 3};  
        for (auto it = vec.begin(); it != vec.end(); ++it) {  
            // it 是一个 std::vector<int>::iterator  
        }  //忘了迭代器咋写，auto是个好方法
        ```

     

47. ```cpp
    //if (depth ==25 && w==13 && b==12 && check())//&&短路了，return过程
    if (depth==25){
        if (w==13 && b==12 && check())ans++;//是否合法
        return;//depth==25无论是否和棋都要返回 
    }
    ```

48. 代码丢给deepseek，来骂我写的旧式依托答辩

49. 黑色终端窗口会显示运行时间（玄学，这你也信？），dfs深搜时先选择更佳的搜索方向，避免超时TLE

      - <img src="D:\Node-typora\note-picture\image-20250407214116774.png" alt="image-20250407214116774" style="zoom: 33%;" />
      
      - C语言的输入输出也比cpp语言的更高效

50. 注意变量名**是否设重**，尤其是i，j等for循环变量常客

51. ```cpp
    const int N=1e6+5;
    int vis[N][N][N];//爆栈，爆堆，爆经验，爆装备
    ```

    ```cpp
    const int N = 1e5 + 10;
    struct gezi{
    	ll box[N];
    }a[N];//数组过大 
    ```

     **减少栈内存占用**

     避免大型局部变量：若需定义大数组（如`int a[1000000]`改用动态内存分配（堆区）或全局/静态存储）

     **栈空间限制**：函数内的局部变量（包括数组）存储在栈区，而栈空间通常较小（默认约1-8MB）。当数组总大小超过栈容量时（如`N=1e6`时，三维数组占用约`1e18 * 4B`，远超栈容量），会引发栈溢出==stackoverflow==

52. 根据大数计算答案，通常输出小范围数据来找规律。**写递归要写递归出口哈（dfs就是基于递归的）**

53. ```cpp
    while (cin >> t.ans >> t.you >> t.time)
    ```

    - 这种方式的while循环，可以读取到无输入为止，吧。时间戳是毫秒

54. ```cpp
    for (int i=0; i<=n; i++){
        if(desk[i][i]==1)s3++;//主对角线
        if(desk[i][4-i])s4++;// 副 
    }//巧妙地在一个循环里面检验
    ```
    
55. 基础的位运算：

       - &：位与运算（and），有0则0。 （给定数组，选择若干个数字做 and 运算，**最小化**结果）
       -  |：位或运算（or），有1则1 。 （给定数组，选择若干个数字做 or 运算，**最大化**结果）
       - ^： 位异或运算（xor），相异则1，相同才0 。（本质上是**二进制不进位加法**）
           - 性质：加法的逆运算是减法，而异或运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变即：`a^a = 0, a^b^b = a` 。

56. **Suf**fix后缀

57. |         语句          |    类型     | 值范围是否合法 |       结果        |     适用场景     |
       | :-------------------: | :---------: | :------------: | :---------------: | :--------------: |
       |     `a = INT_MIN`     | `long long` |       是       | 正确存储`INT_MIN` | 兼容`int`极小值  |
       | `long long a = -1e18` | `long long` |       是       |  正确存储`-1e18`  | ==极大负数需求== |
       |    `int a = -1e18`    |    `int`    |   否（溢出）   | 未定义行为（UB）  | 错误用法，需避免 |

       `ll a = INT_MIN`就跟没开ll似的，处理大数就可以用`1e18`、`-1e18`

58. 打表：<img src="D:\Node-typora\note-picture\image-20250410215022366.png" alt="image-20250410215022366" style="zoom: 25%;" />

59. 最大公约数gcd：greatest common divisor;
    最小公倍数lcm：least common multiple

    ==辗转相除法==，即**欧几里得算法**

      - 介绍：<font color=red>GCD求解最大公**约数**</font>---------------**O(log(min(a, b)))**

        - ```cpp
            // 递归实现
            int gcd(int a, int b)
            {
                return b == 0 ? a : gcd(b, a % b);
                //这里的b充当余数和下次辗转的余数，余数为0时，此时除数a，即为最大公约数
            }
            ```

        - ```cpp
            // 迭代实现
            int gcd(int a, int b) {	//a,b顺序无所谓
                while (b != 0) {
                    int temp = a % b;
                    a = b;
                    b = temp;
                }
                return a;
            }
            ```

      <font color=red>`lcm`函数求解最小公倍数</font>，基于`gcd`函数

      - **abs(**两数之积**)** / 二者的最小公约数(gcd)

        - ```cpp
            #include <cstdlib>  // 用于 abs(int) 函数
            int lcm(int a, int b) {
                if (a == 0 || b == 0) return 0;  // 避免除以零
                return std::abs(a * b) / gcd(a, b);
            }
            ```

              **==优化==**：若处理大整数，建议调整计算顺序防止溢出：

            ```cpp
            //前提先进行：abs(a), abs(b)
            return (a / gcd(a, b)) * b;  // 先除后乘，减少中间值大小，防溢出
            ```

  最终代码：

  ```cpp
  #include <iostream>
  #include <cstdlib>   //不行就打万能头文件
  using namespace std;
  int gcd(int a, int b) {
      return b==0?a:gcd(b, a%b);    //a/b);错-------------这是取余哈
  }
  int lcm(int a, int b) {
      if (a == 0 || b == 0) return 0;
      a = abs(a);//-------------------------------处理负数前
      b = abs(b);
      return (a / gcd(a, b)) * b;//先除后乘
  }
  int main() {
      cout << "LCM of 12 and 18: " << lcm(12, 18) << endl;  // 输出 36
      return 0;
  }
  ```

  扩展：计算多个数的最小公倍数

  - ```cpp
      int lcm_multiple(int a, int b, int c) {
          return lcm(a, lcm(b, c));  // 链式调用
      }
      ```

  - 也可以直接`lcm(a, lcm(b, c));`

60. <font color=red>注意题目要求运算和输出的是下标，还是下标对应的数组值</font>

      - ```cpp
          //ll temp = i*j*k * lcm_pro(i, j, k) / (lcm(i, j) * lcm(i, k) * lcm(j, k));
          //不是下标，是h值
          ll temp =  h[i]*h[j]*h[k] * lcm_pro(h[i], h[j], h[k]) / (lcm(h[i], h[j]) * lcm(h[i], h[k]) * lcm(h[j], h[k]));
          
          if (temp > s) {
              s = temp;
              ans.a = h[i];ans.b = h[j]; ans.c = h[k];
          }
          //s = max(s, temp);
          //ans.a = i;ans.b = j; ans.c = k;   写在这里，都会执行更新，肯定wa掉
          ```

61. - check[row] [i]：这就是你写的函数（row， i）？搞笑呢

      - cpp的io函数改成c的，scanf、printf都写反，写迷糊，逗我呢

62. 拿到两个数组别发愣，**相减**一下说不定有思路了---本质就是构造

63. **容斥原理**也要想到-----不重不漏

64. `nth_element` 是 C++ 标准模板库（STL）中一个高效的排序相关算法，主要用于部分排序和快速定位特定位置的元素。[P1923 【深基9.例4】求第 k 小的数 - 洛谷](https://www.luogu.com.cn/problem/P1923)

     - 分治的思想

65. `mid=1+(r-1)/2`是一种防止l+r溢出整数范围的一种写法，数学上等价`(l+r)/2`

66. ```cpp
    vector<int> nums;
    int temp;
    cout << "输入整数（以空格分隔，按 Ctrl+Z 结束，表示输入结束）: ";
    while (cin >> temp) {
        nums.push_back(temp);
    }
    ```

67. ```cpp
    cout << ((x&0x0000ffff)<<16 | (x&0xffff0000)>>16) <<endl;
    ```

    - **提取低16位并左移**
        `(x & 0x0000ffff) << 16`
        - `0x0000ffff` 是掩码（二进制为低16位全1，高16位全0），用于保留`x`的低16位，屏蔽高16位。
            - <font color=red>16进制占二进制位数4，f:1111</font>
        - 左移16位后，原来的低16位会被移动到高16位的位置。
            ​**​示例​**​：若低16位是 `0x5678`，左移后变为 `0x56780000`
    - **提取高16位并右移**，同理
    - **合并两部分**：`|` 操作符将上述两部分按位“或”运算，合并成一个新整数

68. ```cpp
    cout << 'A' + ans[i]-10;//返回输出的是整型
    ```

    - 对于16输出70（=65+16-10），而不是F

69. ```cpp
    long long ans = 1;
    for (int i=1; i<=100; i++) ans *=i;
    cout << ans << endl;//输出0，阶乘值超出 long long 范围，多次溢出导致二进制截断
    ```

70. ```cpp
    for (int i=10; i<=100; i++){
        if (i %2 && i%3 && i%5 && i%7)cout << i << ' ';
        //i不是质数2、3、5、7的倍数，i就是质数。这样写得到了100以内所有的质数
        //***可以认为2、3、5、7就是基准数，其他质数的倍数也就是这些数的倍数***
    }
    ```

71. **`sizeof(arr) / sizeof(*arr)`**：用总字节数除以单个元素的字节数，得到数组的元素个数

    - `*arr`等价于`arr[0]`

72. <font color=red>不要贸然地对循环break剪枝</font>，**测试用例**的剩余**输入数据残留**在输入流中后续测试用例会读取到错误的数据，产生连锁错误

73. ```cpp
    int num[100];
    for (int i=0; i<100; i++)num[i] = 0;//i<=100会导致越界访问，算法题结果正确也会爆0！！
    ```

74. 后置++会在同行的右边就**立即开始生效**（编译器从左往右）

    - ```cpp
        sum += w[i++]*w[2*n-i+1];//这里后置++，不会影响w[i++],但是会立马影响到w[2*n-i+1]
        ```

75. `sum += w[i]*w[2*n-i+1];`sum为`long long`类型，w数组为`int`类型，w数组存储数据范围在1~1e5

    - **乘法运算阶段的溢出**
        虽然 `sum` 是 `long long` 类型，但 `w[i]` 和 `w[2*n-i+1]` 均为 `int` 类型。在 C/C++ 中，​**​两个 `int` 类型相乘时，结果仍然是 `int` 类型​**​。
        <font color=red>若乘积超过 `int` 的范围（即 `2^31-1 = 2,147,483,647`），会发生==溢出==，此时即使赋值给 `long long`，结果也已是错误的截断值</font>
    - **示例计算**：
        假设 `w[i]` 和 `w[2*n-i+1]` 均为 `1e5`，则乘积为 `1e10`，远超 `int` 的最大值，导致溢出为负数或错误值。
    - **解决方案**：
        - 1.将操作数显式转换为 `long long` 后再相乘：`sum += (long long)w[i] * w[2*n - i + 1];`
        - 2.将w数组类型也定义为long long

76. 字符char和int类型的联系-------ascll码

    - `vector<int> ve; cout << (char)ve[i];`
    - `vector<char> ve; cout << ve[i];`
    - `int temp = 257; char < temp?temp = char: ;`

77. `std::accumulate` 是 C++ 标准库 `<numeric>` 头文件中的一个通用累积计算函数，支持对容器或数组中的元素进行累加或其他自定义操作

78. 三元运算符 `  ? : ` 要求两个分支都必须是完整的表达式，而冒号 `:` 后的空语句 `;` 会导致**主表达式缺失**

    - ```cpp
        sum += (h[i] > mid) ? (h[i]-mid) : 0;    // 更推荐的写法
        ```

79. 思路没有任何问题，答案输出少了，就要回归题目，睁大我的小眼睛看看！！！10^4^是1000吗？？？？？

    - [0立方尾不变 - 蓝桥云课](https://www.lanqiao.cn/problems/676/learning/)翻译人话：统计 1~**10000** 中满足 i^3^ mod 10^k^=i的数的个数（其中k是i的位数）

80. 求最小值，初始化为无穷大：

    - ```cpp
        memset(dp, 0x3f, sizeof(dp));
        ```

    - 初始化无穷大都是用==0x3f==，这个是`memset`的特性

    - |          赋值方式           | 结果（`int` 类型） |                            用途                            |
        | :-------------------------: | :----------------: | :--------------------------------------------------------: |
        |    `memset(dp, 0, ...)`     |    `0x00000000`    |                          清零数组                          |
        |    `memset(dp, -1, ...)`    |    `0xffffffff`    |                   初始化 -1（补码全 1）                    |
        |   `memset(dp, 0x7f, ...)`   |    `0x7f7f7f7f`    |                 约 2.14e9（接近 int 上限）                 |
        | **`memset(dp, 0x3f, ...)`** |    `0x3f3f3f3f`    | **安全大数**（常用优化）<br />1e9 级别，适合 32 位整数运算 |

81. 在C++中，出现 `[Error] reference to 'next' is ambiguous` 错误通常是因为编译器在多个作用域中发现了同名(摩棱两可)的 `next` 符号，无法确定具体引用哪一个

    -  **命名冲突（最常见原因）**：代码中可能同时存在用户自定义的 `next`（如结构体成员、变量名）和**标准库**中的 `next`（如 `std::next` 迭代器函数）

82. 类型不匹配问题：

      `cannot convert 'std::string' to 'std::map<std::string, int>::mapped_type {aka int}' in assignment` 是由于尝试将 `std::string` 类型的值直接赋值给 `std::map<std::string, int>` 中 `int` 类型的键值对导致的类型不匹配问题

83. 当题目数据范围很小时，一眼看没啥思路，可能就是要你暴力枚举把，dfs暴搜

84. 对于多个测试样例的输入的题目，使用while(t--)内，需要对**每一组样例<u>公用的</u>变量数组进行重置**

85. ```cpp
    //打调试一定要在提交前，将调试改回来 ------------做个标记回头好改！
    //时间复杂度1000^2----那就开大点！！！ 
    ```

86. `a[j] & a[i] != 0`因为运算符优先级的问题，会被解析为`a[j] & (a[i] != 0)`

    - <font color=red>`!=`的优先级高于`&`</font>

87. ==substr(   ,   )函数==：用于从原字符串中提取指定位置的子串，即截取字符串

    > substr(截取起始地址， 截取正数长度)

    - **长度超出实际范围**：
        - <font color=red>自动截取至字符串末尾</font>（如 `"hello".substr(2,10)` → `"llo"`）
    - 语法：字符串`s.substr()`，访问成员函数似的

88. ==reverse(first，last)函数==包含在cpp的STL库中的<algorithm>头文件中。

    - 是 C++ 中高效且通用的**序列反转**工具，通过迭代器操作支持多种容器，适用于需调整元素顺序的场景。时间复杂度是O(n)的。
    - 使用时需注意**迭代器范围**和**容器类型限制**，并优先考虑原地修改的特性
        - **前闭后开区间**：实际反转范围是 `[first, last-1]`
        - 支持容器：顺序容器：`vector`、`string`、`deque`、`list`、`array`

89. 








- 怎么解决typora文件的图片的移植问题

**希腊字母表**

| ==α== | \alpha   | ==β== | \beta     | χ     | \chi    | δ    | \delta  | ϵ    | \epsilon    |
| ----- | -------- | ----- | --------- | ----- | ------- | ---- | ------- | ---- | ----------- |
| η     | \eta     | μ     | \mu       | ν     | \nu     | Δ    | \Delta  | ε    | \varepsilon |
| ϝ     | \digamma | τ     | \tau      | π     | \pi     | γ    | \gamma  | κ    | \kappa      |
| υ     | \upsilon | ==θ== | \theta    | ϖ     | \varpi  | Γ    | \Gamma  | ϰ    | \varkappa   |
| Υ     | \Upsilon | ϑ     | \vartheta | Π     | \Pi     | λ    | \lambda | ψ    | \psi        |
| ζ     | \zeta    | σ     | \sigma    | ϕ     | \phi    | Λ    | \Lambda | Ψ    | \Psi        |
| ξ     | \xi      | ς     | \varsigma | ==φ== | \varphi | ω    | \omega  | ρ    | \rho        |
| Ξ     | \Xi      | Σ     | \Sigma    | ==Φ== | \Phi    | Ω    | \Omega  | ϱ    | \varrho     |


# 代码托管-git

git是什么？

- 免费开源的分布式版本控制系统。
    - 保存文件的所以修改记录，使用版本号区分。
    - 恢复和保留的作用
- github是代码托管平台---存放和管理代码的网盘

有什么用？为什么要学？什么时候学？要学什么？哪些是重点？

怎么学？

[Git的基本 - 管理历史记录的数据库 - 《猴子都能懂的GIT入门》 - 书栈网 · BookStack](https://www.bookstack.cn/read/backlog-git-tutorial/3.md)

有哪些方法和资源？面试会考什么？



写博客。好习惯











# 枚举&暴力

1、枚举：是**基于已有知识**来猜测答案的一种问题求解策略

- 枚举的思想是不断地猜测，从可能的答案集合中一一尝试，然后再判断题目的条件是否成立。枚举每一种可能性
- <font color=red>重要思路</font>：求最（大）值问题——<font color=red>倒着枚举</font>，找到的第一个符合答案即最终答案

2、暴力（模拟）：直接模拟题目中要求的操作来求解

- 模拟题目通常具有码量大、操作多的特点。由于它码量大，经常会出现难以查错的情况，如果在考试中写错是相当浪费时间的。但是暴力的思路一般较为简单
- 利用题目所给信息转化为较为简单的解决方案—存储数据结构

- **着重考虑时间复杂度**

3、例题

1. [lg1003](https://www.luogu.com.cn/problem/P1003)

  - 题意：在直角坐标系的第一象限中铺设地毯
  - 变量设计：与题目所给保持一致，按需新增变量
  - 看输入输出样例，准确理解题意
  - 数据范围：只看对于100%的数据
  - 找思路，代码实现
  	- 思路：  
          - <font color=red>从后往前枚举</font>地毯
            - （因为后覆盖的地毯在上面，后来居上，而题目正好要求最上面的地毯），如果有一个地毯满足条件（盖住了指定点）就直接输出，并退出。如果没有地毯满足条件，就输出-1。
        
   - 可优化点：

     - 合并条件判断 - 减少嵌套
     - 直接输出返回 - 避免使用额外变量ans

     2. [59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/description/)

       思路：

       - 生成一个 n×n 空矩阵 mat，随后模拟整个**顺时针向内环绕**的填入过程：

       	定义当前<font color=red>左右上下边界 l,r,t,b</font>（l=0,r=**n-1**,t=0,b=n-1）

       	初始值 num = 1，for循环num++，迭代终止值 num == n * n(不可以n^2)

       	当 num <= n*n 时，始终按照 **从左到右 从上到下 从右到左 从下到上** 填入顺序循环

       	每次填入后，执行 num += 1：得到下一个需要填入的数字；

       	==更新边界==：例如从左到右填完后，上边界 t += 1，相当于上边界向内缩 1。

       	最终返回 mat 。

       原理：

       - 模拟填充整个n*n矩阵的过程，时空复杂度都为O(n^2^)---最优


3. [P1328 NOIP 2014 提高组 生活大爆炸版石头剪刀布 - 洛谷](https://www.luogu.com.cn/problem/P1328)

	分析：

	- 题目中甲对乙的结果可以**现成的抽象为得分表**
	- 出拳都是有周期性规律，运用到取模

	思路：

	- **将得分表整理成一个整数型2维数组**，我们在查看结果的时候只要将取这个数组的f[**a[i]**] [**b[j]**]便可以知道结果,**<font color=red>交替计算</font>**两人的得分
	- <img src="C:/Users/32520/AppData/Roaming/Typora/typora-user-images/image-20250217211329752.png" alt="image-20250217211329752" style="zoom:25%;" />
	- 定义两人各自的出拳变量x,y，**取模**实现出拳的周期规律，例：x = (x + 1) % Na



# 前缀和&差分

导图：[算法集训 - 幕布](https://mubu.com/app/edit/home/fvsDf-IpYz#m)

1、前缀和：前缀和可以简单理解为「数列的前 n 项的和」。是一种重要的**预处理**方式（用于降维）。

- 一维：有 N 个的正整数放到数组 A 里，现在要求一个新的数组 B，新数组的第 i 个数 B[i] 是原数组 A 第 0 到第 i 个数的和。
	- ==sum[i] = sum[i - 1] + a[i]==
	- 所以所谓的sum数组也就是<u>A数组的</u><font color=red>**前缀和数组**</font>
- 二维：有 n * m 个的正整数放到n *m的二维数组A中,现在要求一个新的二维数组数组 B，新数组的 B[i] [j]是原数组 **A[1] [1] 到A[i] [j]的和**。(矩形范围)
	- 多维前缀和的普通求解方法几乎都是基于<font color=red>容斥原理</font>[^1]
	- ==sum[i] [j] = sum[i] [j-1] + sum[i - 1] [j] + a[i] [j] - sum[i-1] [j-1]==<img src="D:\Node-typora\note-picture\image-20250331150426710.png" alt="image-20250331150426710" style="zoom: 25%;" />sum前推后相加

2、差分：一种和<u>前缀和</u>相对的策略，可以当做是求和的**逆运算**。给定前缀和数组sum[i]，求**对应的原数组，即**<font color=red>差分数组</font>

- 一维：ans[i] = sum[i] - sum[i-1]
- 二维：a[i] [j] = sum[i] [j]  - sum[i] [j-1] - sum[i - 1] [j] + sum[i-1] [j-1]
	- 注意：==在1位置开始存数==，避免使用0位置，计算时导致越界

3、应用

1. 求<font color=blue>区间和</font>——前缀和

	- 一维：
		- 每次求[l, r]的和：**ans = sum[r] - sum[==l - 1==]**---------<font color=red>**动手画图去推**</font>

	- 二维：
		- 求[x1, y1]~[x2, y2]的和：<img src="D:\Node-typora\note-picture\image-20250331151115325.png" alt="image-20250331151115325" style="zoom:33%;" />（记住推导思路，现场想出以下公式)
		- ans = sum[x2] [y2] - sum[**x2**] [y1-1] - sum[x1-1] [**y2**] + sum[x1-1] [y1-1]

2. <font color=blue>差分标记数组</font>：用于解决**元素变化问题**

	如下m个（变化）操作（叠加）：**l r q**：把[l, r]内所有元素，都加上q（可正可负）

	<img src="D:\Node-typora\note-picture\image-20250331153708977.png" alt="image-20250331153708977" style="zoom: 50%;" />----如何解决？
	
	- 一维：另弄一个**b**数组，进行操作：
		- b[l] + q, b[==r + 1==] **- q**
		- 计算sum**b**前缀和数组
		- ==**sumb[i] + 原**数组a[i]==，即可得到<u>m个操作（可叠加循环前两点）后的==答案数组==</u>
		- 图示：<img src="D:\Node-typora\note-picture\image-20250331153911028.png" alt="image-20250331153911028" style="zoom:33%;" />
	- 二维：如下m个操作：**x1,y1 x2,y2 q**：把a[x1, y1]~a[x2, y2]这个矩形内的所有元素，都加上q（可正可负）
		- 另弄一个b[i] [j]数组，进行操作：
			- b[x1] [y1] += q
			- b[**x1**] [y2+1] -= q
			- b[x2 + 1] [**y1**] -= q
			- b[x2 + 1] [y2 + 1] += q
		- <img src="D:\Node-typora\note-picture\image-20250331155149363.png" alt="image-20250331155149363" style="zoom: 50%;" />-q+q的操作使前缀和数组在非矩形区域元素值，在与原数组相加合并后不发生改变
		- 计算sumb[i] [j]前缀和数组
		- **a[i] [j] + sumb[i] [j]，即可得到m个操作后的答案数组**

4、例题

1. [B3612 【深进1.例1】求区间和 - 洛谷](https://www.luogu.com.cn/problem/B3612)

	思路：ans = sum[r] - sum[l - 1]

2. [P1387 最大正方形 - 洛谷](https://www.luogu.com.cn/problem/P1387)

	分析：区间和=正方形面积

	思路：转变为计算区间和——可以使用到二维的前缀和数组

	- 枚举（正方形）区间的<font color = red>右下角</font>

	- 再枚举边长r

		- ```cpp
			r <= min(n, m);	//cpp内置函数min
			```

	- 对该正方形区间的sum值与边长r*r，比较

	- 注意：该矩形可能没有1元素，即答案可能为0

		- 可以在输入个元素的时候，进行判断，打个标记flag。如果有一个元素为1，就说明边长r至少为1

3. [P3397 地毯 - 洛谷](https://www.luogu.com.cn/problem/P3397)

	分析：抽象为在二维数组上的元素变化问题。每块格子上的地毯数就是差分标记数组sumb[i] [j]对应位置的值

	思路：

	- 弄一个b[i] [j]数组
	- 进行对应元素变化
	- 求sumb[i] [j]
	
	代码
	
	- ```cpp
	    #include <iostream>
	    #include <cstdio>
	    using namespace std;
	    int b[1005][1005];//差分标记数组b
	    sumb[1005][1005];//输出最后的sumb数组 
	    int x1,y1,x2,y2;
	    int main()
	    {
	    	int n, m;//n^n格子，m个摊子
	    	cin >> n >> m;//下标从1开始
	    	while (m--)
	    	{
	    		cin >> x1 >>y1 >> x2 >> y2;
	    		//容斥原理，画图解差分
	    		b[x1][y1]++;b[x1][y2+1]--;b[x2+1][y1]--;b[x2+1][y2+1]++;
	    	}
	    	//最后求sumb-----不是求区间和 
	    	for(int i = 1;i<=n;i++) 
	            for (int j= 1;j<=n;j++)
	                sumb[i][j] = sumb[i-1][j]+sumb[i][j-1] - sumb[i-1][j-1]+b[i][j];
	    	//输出sumb
	    	for(int i = 1;i<=n;i++) 
	    		for (int j= 1;j<=n;j++)
	    			cout << sumb[i][j] << ' ';
	    		cout << endl;
	        
	        return 0;
	    }
	    ```
	
	- 

4、算法模板



# 尺取法

1、尺取法：一种利用<font color=red>双指针</font>遍历获取满足条件的区间[^2]（<font color=red>滑动窗口</font>）的算法。

- 是一种线性算法。过程：
	- ==首先枚举r==，不断得到合法区间。记（l， r）为一个序列内以**<font color=red>r</font>**为右端终点的合法区间
	- ==然后枚举l==，l++，随着l的增大，区间不断缩小，直至不合法为止
	- r和l都不会往回退，<font color=blue>时间复杂度O(n)</font>

- **条件**：区间权值大小满足随区间长度**单调变化**，即区间越长区间和（权值）越小（或越大）

    - > 不过当然是在增加删减元素的区间和原区间相较单调变化

- 优点：
  - 不会枚举一定不满足条件的区间
  - 不会枚举即便符合条件但不是解的区间
- 性能：
  - 比直接暴力枚举区间效率高很多，尤其数据量大的时候
  - 一般用于求取有一定<u>限制的区间个数</u>或<u>最短区间</u>
- 注意点和错误思想：
  - 合法就继续（左）缩，不合法就（右）扩，或者相反
  - 使用两层循环来实现O(n)

2、例题

1. [LCR 008. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/2VG8Kg/description/)

  分析：想要使用滑动窗口法，如何判断问题是否符合使用条件呢

  - ==题目提示==`1 <= nums[i] <= 10^5`，所以数组中均为正整数，权值一定单增
  - vector数组是从0开始存数的

  思路：

  - l=r=1
  - 当`sum<target`时，右移指针r来**扩大**窗口，<font color=red>sum**+**nums[r]</font>，不用遍历计算sum
  - 当`sum>=target`时，右移指针l来**缩小**窗口，<font color=red>sum**-**nums[l]</font>，寻求最小答案
  - 更新答案min（ans）

  注意：

  - 边界情况，都不满足时

2. [713. 乘积小于 K 的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/subarray-product-less-than-k/description/)

  分析：

  - <font color=red>大区间合法，其中的小区间一定合法</font>。计算==r-l+1,==
  	- 例计算得==区间长度为3（**右窗口不动**，滑动左窗口，则固定r右窗口的子区间个数就有3）==
  	- <font color=blue>不用担心重复或遗漏，因为右窗口会轮流固定在每个元素上</font>
        		- <img src="../My_files/qqfiles/1740193224624.jpg" alt="1740193224624" style="zoom: 25%;" />
  - <font color=red>合法往右滑动，不合法往左滑动</font>

  思路：

  - l=r=0，r++扩大区间
  - 区间合法则**计算r-l+1(合法小区间数)**，继续扩大(不用缩小l窗口，因为小区间一定是合法的，且计算在内)
  - 扩大后不合法就l++，缩小区间，合法后再计算r-l+1
  - 合法再扩大，直至r窗口滑到顶（越界），算法结束

  注意：

  - 是否合法，取决去计算grade，扩大则grade+nums[r],缩小则grade-nums[l]，不需要遍历

  代码：

  - ```cpp
      int numSubarrayProductLessThanK(vector<int>& nums, int k)
      {
      	//一个区间小于k，那么它的所有子区间都小于k
      	int l , r;l = r = 0;
      	int sum = 1;int ans = 0;
      	while (r<nums.size())
      	{
      		sum *= nums[r];
      		while (l < r && sum >= k)
      		{//不合法 ---缩 
      			sum /= nums[l];l++;
      		}
      		//合法 
      		if (sum < k)ans += r-l+1;//固定r，计算子区间数 
      		r++;//然后继续扩 -----当l=r也不合法时，也可以继续扩 
      	}
      	return ans;
      }
      ```

3. [2379. 得到 K 个黑块的最少涂色次数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/description/)

	分析：不止一种涂法，只求最少的涂黑B次数

	思路：<font color=red>固定`r-l+1 = k`，l、r窗口同时滑动</font>，区间中w出现次数最少，即解

	- 长度为k的区间，在总长n中有**n-k+1**个

3、模板

- 写法1：两层循环

    ```cpp
     int minSubArrayLen(int target, vector<int>& nums) //引用传参，并非简单的拷贝 
    {
    	int ans = INT_MAX;	//求最小，将其一变量赋为尽可能大值 
    	int l, r;
    	l = r = 0;
    	int sum = 0;
    	while (r < nums.size()) //-------------------外层实现不合法就扩大
    	{
    		sum += nums[r];
    		while (l <= r && sum >= target ) //----------内层实现合法就缩小
    		{
    			int x = r-l+1; //记录本次合法区间长度 
    			ans = min(ans, x);
                sum -= nums[l];l++;//缩小窗口 
    		}
    		r++;
    	}
        //边界情况，都不满足时
    	if (ans == INT_MAX) return 0;return ans;
    }
    ```

- 写法2：判断是缩是扩（能不能扩）

    ```cpp
    int minSubArrayLen(int target, vector<int>& nums)
    {
    	int l, r;l = r=0;
    	int ans = INT_MAX;
    	int sum = nums[r];
    	while (l <= r && r<nums.size()) 
    	{
    		if (sum >= target)		//---------------------合法（缩）
    		{
    			ans = min(ans, r-l+1);
    			sum -= nums[l];l++;//左缩小 
    		}
    		else if (r<nums.size()-1) //---------------不合法（扩，注意判断是否越界）
    		{
    			sum += nums[r+1];////r不能越界
    			r++;//右扩 
    		}
    		else break;//当r达到最右段，即size-1。就结束
    	}//合法就得缩，不合法也扩不了了，所以终止循环滑动
    	if (ans == INT_MAX)return 0;return ans; 
    }
    ```

- ==常见模板==

    ```cpp
    int l,r;l = r=0;			//初始化
    //code..
    while (r < n.size())		//右边框移动
    {
        //code..
        while(l < r && check(xxx))	//检查是否合法
        {
            //code..
            l++;        			//缩小
        }	
        r++;						//扩大
    }
    ```

    







# 二分

1、二分查找：以在一个升序数组中查找一个数为例。或者找**不小于x的第一个数（lower_bound( , , )）**等等

- 它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；

- 如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需到右侧查找；

- 如果中间元素大于所查找的值同理，只需到左侧查找

	<font color =red>前提：</font>

	- 有界
	- 单调（有序）
	
	图示：<img src="C:/Users/32520/AppData/Roaming/Typora/typora-user-images/image-20250222213246149.png" alt="image-20250222213246149" style="zoom:33%;" />
	
	注意：
	
	- 跳出循环的边界条件
	- 小李子模拟判断是否会死循环
	
	时间复杂度：==o(logn)==

2、二分查找的应用（本质：<font color=red>猜答案——去二分答案</font>）

- 最优解，出现题眼

	- 最小化v.最大值n.


	- 最大化v.最小值n.
	
		示例：<img src="C:/Users/32520/AppData/Roaming/Typora/typora-user-images/image-20250222212834739.png" alt="image-20250222212834739" style="zoom: 33%;" />


- 其他求最值问题——需要将O(n)—>O(logn)

3、例题

1. [P2678 NOIP 2015 提高组\] 跳石头 - 洛谷](https://www.luogu.com.cn/problem/P2678)

  分析：画图，手动去模拟这个过程

  草稿：<img src="../My_files/qqfiles/qq_pic_merged_1740462895698.jpg" alt="qq_pic_merged_1740462895698" style="zoom:33%;" />

  思路：最大化最值问题——采用二分

  - 二分需要满足的条件：
    - 有界：这里我们去二分答案，即最短跳跃距离s。由题知：==0<=s<=L==
    - 有序：二分答案，往左半边猜测的s越小，往右越大

  - 搬走岩石的数目x<=M，才符合题意，这时猜测的mid可能是最优解。我们要最大化最短距离，所以需要继续向右半边猜s，即mid。
  - x>M，说明搬走的岩石数多了，不符题意，也就是猜测的mid大了，需要向左半边猜小一点

  问题：如何让求x？

  - 让每块岩石到起点的距离D[i]，与现在now指针指向的岩石到起点的距离now相减，满足<font color=red>>=mid</font>，则这个岩石可以作为跳跃的岩石，更新now = D[i]
  - 不满足，则x++，即将这块岩石移走

注意：

- 终点的石头不能移，但可以将终点前最后一个石头移走来达到要求

代码：

- ```cpp
    ```

- 

2. [LCR 073. 爱吃香蕉的狒狒 - 力扣（LeetCode）](https://leetcode.cn/problems/nZZqjQ/description/)

  分析：最大化最小值，让珂珂狒狒尽可能地慢慢吃

  思路：

  - 二分答案----即求谁就二分谁mid
    - 有界：[1, max(香蕉最多的一堆)]

    - 有序：猜每小时吃香蕉的根数mid

  - x为猜mid时，需要花费的小时
    - time<=H，mid可能为最优解，往左半边猜，尽可能大
    - time > H，mid猜小了，吃的太慢了，往右半边猜

  - time的计算，piles[i] / k，然后<font color = red>向上取整</font>

 注意：

  - 需要找到 max(香蕉最多的一堆)
  - `piles.length <= H <= 1e9`，int取值范围-2^31^~2^31^-1，而2^31^≈2.147483648×10^9231^≈2.147483648×10^9^，保险起见可以用`long long`来存储time

代码：

- ```cpp
    int minEatingSpeed(vector<int>& piles, int h) 
    {
    	int len = piles.size();//0~len
    	int maxans = 0;
    	for (int i=0; i<len; i++){
    		maxans = max(piles[i],maxans);//----maxans要在比较数当中
    	}
    	int l=1, r=maxans;//二分答案区间 ---------------l,r,mid均为答案值。[l,r]
    	int mid;//猜测答案 
    	int minans = r+1;
    	int time;
    	while (l <= r)
    	{
    		mid = (l+r)/2;
    		time = 0; //piles发生了改变？？ ---取模，除法 
    		for (int i=0; i<len; i++)
    		{
    			if (piles[i] < mid )//&& piles[i]%mid !=0)
    			{
    				time++;
    			}
    			else if (piles[i] % mid == 0)
    			{
    				time += piles[i]/mid;//可以整除 
    			}
    			else
    			time += piles[i]/mid + 1;//不能 
                /*------更简洁的写法
                time += piles[i] / mid;
    			if (piles[i]%mid != 0)
    			{//有余数，还要再花一小时 
    				time++; 
    			}
                */
    		}
    		if (time <= h)
    		{//合法 ---但还能再慢一些吗 
    			minans = min(minans, mid);
    			r = mid-1; 
    		}
    		else l = mid+1;//时间来不及，吃快一点 
    	}
    	return minans;
    }
    ```

4、==二分查找&二分答案模板==

- ```cpp
    int l = 0, r = max_possible_ans;
    int mid;//猜测答案
    while (l <= r)
    {
        mid = (l + r)/2;
        if (......)
        {
            //合法
            ans = max(ans, mid);//最大化最小值
            l = mid+1;
            //ans = min(ans, mid)//最小化最大值
        }
        else r = mid-1;//猜小了
    }
    //查找区间[r, l]
    ```
    
    此模板跳出while循环条件为r<l。此时答案并不是me一开始认为的mid。但也可以是mid
    
    - ```cpp
        //跳出循环后再mid一次，mid就是答案（而非循环内的错误mid）
        mid = (l+r)/2;
        cout << mid << endl;
        //等价于
        cout << r << endl;//cout << l-1 << endl;
        ```







# 质数筛法

质数概念：质数，又称素数，即**约（因）数只有1**以及它**本身**的数。

- ==0和1==既不是==质数==也不是==合数==。问啥是合数？----不是质数的就是合数

筛质数：

1. 朴素方法
2. 埃氏筛法
3. 欧拉筛法

## 1、朴素筛法

- 根据定义直接判断**从2到n-1**是否存在n的约数即可,<font color=pink>O(n^2^)</font>。伪代码如下：

	```cpp
	//isprime
	for (int i = 2; i<=n-1; i++){
	    if (n % i == 0)return 0;//有除1和它本身的约数，不是质数
	}
	return 1;
	int main()
	{
	    for (int i=2; i<=n; i++)isprime;
	}
	```
	
- 其实只需要判断**一半n/2**就行，<font color=pink>O(n^2^)</font>

	```cpp
	for (int i = 2; i <= n/2; i++)
	```

- <font color=red>原理：</font>一个数若可以进行因数分解，那么分解时得到的两个数一定是<u>一个小于等于</u>sqrt(n)，一个<u>大于等于</u>sqrt(n)，据此，上述代码中并不需要遍历到n-1，遍历到**sqrt(n)**即可
	因为若sqrt(n)左侧找不到约数，那么右侧也一定找不到约数。因此只要从2枚举到 √n即可。
	
	```cpp
	#include <cmath>
	for (int i = 2; i <= sqrt(n); i++)
	```
	
	```cpp
	for (int i = 2; i*i <= n; i++)//另一种写法
	```
	
	时间复杂度最终降到了<font color=pink>O(n^3/2^)</font>

## 2、埃式筛法

埃拉托色尼选筛法(the Sieve of Eratosthenes)简称埃氏筛法，是**古希腊**数学家埃拉托色尼提出的一种筛选法

- 基本原理：**一个合数总是可以分解成若干个质数的乘积[^6]**，那么如果把质数（最初只知道2是质数）的倍数都去掉，那么剩下的就是质数了

- 步骤：

    （1）先把1删除（1既不是质数也不是合数）

    （2）读取数组中当前最小的数2，然后把2的倍数删去（**被删去的数不会被读取后，进循环**）

    （3）读取数组中当前最小的数3，然后把3的倍数删去（**也就是说被读取到的数都是质数了**）

    .......

    （n）读取数组中当前最小的状态为true的数n，然后把n的倍数删去

    注意：**删倍数**是循环条件 `j += i`，而不是`j++`

- 巧妙点：<font color=red>可以得到2~n所有数的性质（是质数或是合数，通过`isprime数组`）</font>

代码：

- ```cpp
    #include <iostream>
    #include <vector>	//cpp借助stl
    using namespace std;
    vector<int> prime;
    int n, x;
    int isprime[10005];//0：是质数(省初始化)， 1：不是质数（也就是合数） 
    int main()
    {
    	cin >> n;
    	for (int i=2; i<=n; i++){
    		if (isprime[i] == 0){//是质数 
    			prime.push_back(i);//建立质数prime数组*******
    			for (int j = i*2; j<=n; j+=i)//j+=i,而不是j++******
                //for(int j=2; j*i<+n; j++)另一种写法，枚举质数i的倍数
    			{
    				isprime[j] = 1;//删取质数的所有倍数（合数） 
    			}
    		}//这for循环放if外面也行，就是时间复杂度更高了（苦笑不得）
    	}
    	cin >> x;
    	if (isprime[x])cout << "N";
    	else cout << "Y";
    	return 0;
    } 
    ```

缺点：

- 埃氏做了许多无用功，一个数会被筛到好几次，比如6是2和3的倍数，则被筛到了两次，最后的时间复杂度是==**O(nloglogn)**==

    如果我们在筛选时，对每一个数只筛一遍，那么这个时间复杂度将会怎样变化呢？

## 3、欧拉筛法

算术基本定理（唯一分解定理）：任何合数都能表示为若干质数的乘积，且该分解因式是唯一的。（不考虑顺序性）

- **埃式筛法反向利用了此定理的前半句**，这时欧拉加以利用后半句就达到了更低复杂度的质数筛，又称==线性筛==
- 埃式筛法逻辑清晰、代码清晰；欧拉筛逻辑也清晰，代码emmm

**原理**：

- 规定每个合数**只会被它最小的质因数筛去**（后面的质因数直接跳过），这个最小的质因式必定小于它本身。

    eg：15 = **3**x5、110 = **2**x5x11、935 = **5**x11x17

代码：

- ```cpp
    #include <iostream>
    #include <vector>	//cpp借助stl
    using namespace std;
    vector<int> prime;
    int n;
    int isprime[10005];//1：是质数0：不是质数（也就是合数） 
    int main()
    {
    	cin >> n;
    	//初始化，一开始全部认为是质数，用分解出的最小的质数去筛合数（依据唯一分解定理） 
    	for (int i=2; i<=n; i++)isprime[i] = 1;
    	//线性筛
    	for (int i=2; i<=n; i++) 
    	{
    		if (isprime[i])prime.push_back(i);
    		//枚举所有质数数组里的质数
    		for (auto p: prime)
    		{//对合数i*p进行筛除 
    			int temp = i*p;
    			if (temp > n)break;//合数超过讨论范围，直接break
    			else isprime[temp] = 0;//筛掉此合数temp
    			if (i % p == 0)break;//合数temp的i部分已经能被较小的质因数p给筛过了，跳过>p的其他质因数 
    		}
    	}
    	for (auto p: prime)cout << p << " ";
    	return 0;
    } 
    ```

- 









# 快速幂

**引入**：5^10^=？

- ```cpp
	for (int i = 1; i <= 10; i++) ans *= 5;//10个5相乘
	```

- 因此，计算N^x^，时间复杂度为<font color=pink>O(x)</font>，也就是O(n)级，当n>10^8^，则会导致TLE(运行超时)

1、预备知识

- ==进制转换==-----基础

	```cpp
	int b[105], idx;
	int main()
	{
	    cin >> x;//将十进制转换二进制
	    if (x == 0)
	    {
	        cout << x;
	    }
	    else
	    {
	        while(x != 0)
	        {
	            idx++;//从1开始存，也可以从0随你
	            b[idx] = x%2;		//除基取余--->2^n=x,n=log~2x--->logx
	            x /= 2;
	        }
	        for (int i = idx; i > 0; i++)
	        {
	            cout << b[i] << " ";//倒着读
	        }
	    }
	    cout << endl;
	    return 0;
	}
	```

	时间复杂度：<font color=pink>O(logx)</font>，log的角标根据情况来定，这里是2

2、快速幂：==二进制取幂==（Binary Exponentiation，也称平方法）

- 解释：我们将取幂的任务按照指数的 **二进制表示** 来分割成更小的任务
    - 3^13^ = 3^(1101)B^ = 3^8^ · 3^4^ · 3^1^ 
    - 二进制(从左往右数第一位)2^1^,2^2^,2^3^......（最后一位）
- 拆成2的幂次方----2 4 8 16 32 64 128 256 512 1024-----><font color=red>（等于每一位的次方数）`n *= n;`</font>
    - 与二进制就对应上了
    - <img src="D:\Node-typora\note-picture\image-20250321164922411.png" alt="image-20250321164922411" style="zoom:50%;" />
    - 二进制**1有效0无效（有贡献）**，拆成位数是1的次方数
- 问题：使用三进制以上会更好嘛
    - 不会。二进制最佳，n = n*n。使用三进制则n= n * n * n，以此类推

3、对幂进行取模

- 注意：某数的幂很容易超出long long的范围，取余应在范围内进行

- 性质：(a ***/+-** b) <font color = red>% c</font> = (a *% c*) ***/+-** (b *% c*) <font color = red>% c</font>

- ```cpp
    if (j == 1)//1有效有贡献
    {
        ans = (ans*n) % p;//----对ans取余
    }//先赋值再取余等价先取余再赋值
    //ans *=n;ans %= p;
    n = (n*n) % p;	//-----对n取余
    
    cout << ans % p << endl;	//二者之积，也就是最后的ans再取余
    ```

4、代码模板

- ```cpp
    ll ksmi(ll a, ll b, ll mod )
    {
    	//两步：1、对指数b转换二进制；2、对a^b按二进制进行拆分 
    	ll ans = 1;
    	while (b != 0)
    	{
    		//除2取余
    		int x = b%2 ;//从左往右数第一位
    		b /= 2;
    		if (x == 1) 
    		{
    			ans = (a * ans) % mod;
    		}
            //第一位a
    		a = (a*a) % mod;//更新下一位，a^2 a^2^2 a^2^2^2 ...
    	}
    	return ans;
    }
    ```

    常常与**取余**结合使用

5、借助**pow函数**

- `pow`函数是C++标准库中用于计算幂运算的核心数学函数，定义在头文件`<cmath>`中

    函数原型：

    ```cpp
    double pow(double base, double exponent);  // 标准形式，接受两个double参数，返回double
    ```



# 高精度

## 精度加减法

1、引入：

- 大数：指计算的<u>数值非常大</u>或者对运算的<u>精度要求非常高</u>，用已知的数据类型无法精确表示的数值。

	- eg：求Fibonacci数列的第1000个数
	- ​         计算π到小数点后第2000位

- 问题：计算a+b，其中a、b都是现有基本数据类型存不下的数，无法计算。。

	如何解决呢？

2、<font color =red>**核心思想：**使用数组存储，模拟运算过程，注意进制和低位对齐以及结果的输出处理</font>

1. 加法：
    - 数据输入处理、倒着存---使低位对齐
    - 用字符来存数，然后**字符【下标i】-‘0’**得到此时i位置的数字
    - 处理进位问题，减法处理借位问题
        - 两数相加最大位数clen = max(alen, blen)+1;相减则使clen = max(alen, blen)

2. 减法：

    - 细节1：做减法前先判断大小，对负数的处理------   a-b = -(b-a)

        - 字符串长度相同时，直接字符串比较大小<,>,=......

    - 细节2：去掉前导0，但最后一位要留下来！1111-1111 = 0000（输出0）

        - ```cpp
            while (c[clen]== 0 && clen>0) clen--;
            ```

    - 以上争对正整数之间的减法

        - 另外几种情况：正-负数 = 正+正；负数-正 = -（正+正）；负数-负数 = 后-前

3、代码模板

- 加法：

    ```cpp
    #include <iostream>
    #include <cstdio>
    #include <string>
    #include <math.h> 
    using namespace std;
    int a[100], b[100], c[100];//c保存a+b运算结果----开大点没事哒 
    int main()
    {
    	string x, y;//字符串接受大数 ------------------------1
    	cin >> x >> y;
    	//数组 保存并模拟运算 ---倒着存（低位对齐） ----------------------2
    	int j = 0;//在外面定义
    	for (int i = x.length()-1; i>=0;i--)
    	{
    		a[j] = x[i] - '0';//字符Ascn||码相减 得到整型数字 
    		j++;
    	}
    	j = 0;//置0
    	for (int i = y.length()-1; i>=0;i--)
    	{
    		b[j] = y[i] - '0'; 
    		j++;//自然会跳出循环 
    	}
    	//模拟加法运算--对进位的处理------------------------------3
    	int len = max(x.length(), y.length());//0~len-1(下标)
    	for (int i = 0; i < len; i++)
    	{
    		c[i] += a[i] + b[i];
    		if (c[i] >= 10)
    		{
    			c[i+1]++;
    			c[i] -= 10;
    		}
    	}
    	//倒着输出
    	if (c[len] != 0)
    	{//max+1(最高位发生了进位)-------------------------------------4
    		for (int i = len; i>=0;i--) 	cout << c[i] ;
    	}
    	else
    		for (int i = len-1; i>=0;i--) cout << c[i] ;
    	cout << endl;
    	return 0;
    }
    ```

    ```cpp
    int carry = 0;//另外弄一个进位变量，记录进位
    for (int i = 1; i <= 5000 || carry; i++) {
        int sum = f[x-1] + f[x-2] + carry;
        carry = sum / 10;
        f[x] = sum % 10;
    }
    ```

    

- 减法：

    ```cpp
    #include <iostream>
    #include <cstdio>
    #include <string>
    #include <math.h> 
    using namespace std;
    int a[20000], b[20000], c[20000];//c保存a-b运算结果----c要开大点
    int main()
    {
    	string x, y;//字符串接受大数 x，y均大于0 
    	cin >> x >> y;
    	//数组 保存并模拟运算 ---倒着存 
    	int j = 0;//在外面定义
    	for (int i = x.length()-1; i>=0;i--)
    	{
    		a[j] = x[i] - '0';//字符Ascn||码相减 得到整型数字 
    		j++;
    	}
    	j = 0;//置0
    	for (int i = y.length()-1; i>=0;i--)
    	{
    		b[j] = y[i] - '0'; 
    		j++;//自然会跳出循环 
    	}
        //事先判断小-大---并进行处理---------------------------1
    	if (x.length() < y.length() || (x.length() == y.length() && x < y))
            //（一定要是）相同长度时，x > y字符串可以直接比较（字典序） 
    	{//说明x-y为正 （包括0）
    		swap(a, b);// a-b = -(b-a)此时互换后a>b,继续使用相同代码----注意要打印个负号 
    		cout << '-';
    	}
        //模拟减法运算--对借位的处理---------------------------2
    	int len = max(x.length(), y.length());//0~len-1(下标)
        for (int i = 0; i < len; i++)
        {
            c[i] += a[i] - b[i];
            if (c[i] < 0)
            {//需要借位 
                c[i+1]--;
                c[i] += 10;
            }
        }
    	//倒着输出-----去除前置0 ------------------------------3
    	while(len > 0 && c[len-1] == 0 )
    	{
    		len--;//111-110=001=1,111-111=000 = 0
    	}
    	
    	for (int i = len; i>0;i--) cout << c[i-1] ;
    	if (len == 0) cout << '0';
    	cout << endl; 
    	return 0;
    }
    ```
    

## 精度乘除法

1、乘法

- 答案数组c位数：n（位数）* m最多：<font color=red>n+m位数[^5]:</font>

- 如果最高位c[len-1]也要进位，处理前导0时就从**c[len-1]（!=0）**开始

- ==核心：c[i+j] = a[i] * b[j]==<img src="D:\Node-typora\note-picture\image-20250329110020373.png" alt="image-20250329110020373" style="zoom: 50%;" />

- 模板：

    - ```cpp
        #include <iostream>
        #include <cstdio>
        #include <string>
        using namespace std;
        int a[2005], b[2005], c[4005];//c保存答案，最多alen+blen 
        int main()
        {
        	string x, y;cin >> x>> y;
        	int j = x.length()-1;
        	for (int i = 0;i<x.length();i++)
        	{
        		a[j] = x[i] - '0';
        		j--;//倒着存 
        	}
        	j = y.length()-1;
        	for (int i = 0;i<y.length();i++)
        	{
        		b[j] = y[i] - '0';
        		j--;//倒着存 
        	}
        	//模拟乘法
        	int len = x.length() + y.length();
        	for (int i = 0;i<x.length();i++) 
        	{
        		for (int j = 0;j<y.length();j++)
        		{
        			c[i+j] += a[i] * b[j];//------------------------1
        		}
        	}
        	//最后处理进位
        	for (int i = 0;i<len;i++) 
        	{
        		if (c[i] >= 10)
        		{
        			c[i+1] += c[i]/10;
        			c[i] %= 10;//留下个位 ------------------------2
        		}
        	}
        	//除去前导0。 //应该不会。如果最高位发生进位c[len-1] !=0------------------3
        	while (c[len-1] == 0 && len>1) len--;//len至少=1
        	//倒着输出
        	for (int i = len;i>0;i--) 
        	{
        		cout << c[i-1];
        	}
        	cout << endl;
        	return 0 ;	
        }
        ```

2、除法：

- 除法的本质：减法（除数能减出多少个被除数）

    - 高精度除法正是利用这个思想，将**除法改成减法**去写。注意去除前导0。
    - 位数对齐---补0

- 商的位数：n位数除以m位数，商的最多位数为：<font color=red>**n-m+1**</font>(例如最低两位数10，所得结果只能让位数-1)

- 思路：

    1. 利用字符串读入被除数、除数

    2. 把字符串倒着存储到数组中

        - 注意：<font color=red>把数组的0位置空出来，记录数据总位数</font>，从下标1开始存储

    3. 商最多为n-m+1位，进行循环求商的每一位

        - ```cpp
            ans[0] = a[0]-b[0]+1;
            ```

        - a<b，即 ans[0]<0，答案就输出0（小数除大数得0）

        - 循环内：**添位数**，做减法，直至减数小于被减数（能减几次）

    4. 添位数，计算第i=ans[0]位，给被除数b数组添加**i-1个0**。

        - 需要另开一个temp数组存补零（==写个补零函数==）后的被除数
            - <font color=red>将除法转换为减法</font>，直至==减数[^3]==（除数）==小于[^4]==（减不动）被减数temp
                - 整除答案为整数，**余数**留在a数组里面
        - 计算结果填入商ans数组的第i位置上
        - i--，计算下一位。循环操作
    
- 模板

    - ```cpp
        #include <iostream>
        #include <string>
        using namespace std;
        int a[5005], b[20], c[5005];//c保存答案 
        void fill(int t[], int b[], int l) //补零------------------------1
        {
        	t[0] = b[0]+l;
        	int j = 1;
        	for (int i = l+1; i<=t[0];i++)
        	{//从补0完后的数开始填 
        		t[i] = b[j];j++;
        	}
        }
        bool check(int t[], int a[])	//检查-------------------------2
        {
        	//优先考虑大小
        	if (t[0] > a[0])
        	{
        		return 0;
        	}
        	else if (t[0] < a[0])
        	{
        		return 1;
        	}
        	else
        	{//逐一比较 
        		for (int i=t[0]; i>=1;i--)
        		{
        			if (t[i] > a[i])
        			{
        				return 0;//大于被除(减)数 
        			}
        			else if (t[i] < a[i]) 	return 1;
        		}
        	}
        	//完全相等-----不要漏了
        	return 1; 
        }
        void sub(int t[], int a[]) 
        {
        	for (int i = 1; i<=a[0]; i++)
        	{
        		a[i] = a[i]-t[i];//减后直接保存a数组中-----这里就是等于=，不是+=XXXXX
        		if (a[i] < 0) 
        		{
        			a[i] += 10;
        			a[i+1]--;
        		}
        	} 
        	//去除前导0.更新a[0]的长度！！！！！！1-------------------------------3'
        	while (a[a[0]] == 0 && a[0] > 1  )a[0]--; 
        }
        int main()
        {
        	string x, y;cin >> x >> y;
        	//倒着存---注意0位置存长度
        	a[0] = x.length();int j = a[0];//在0位置拿长度 
        	for (int i=0;i<x.length();i++) 
        	{
        		a[j] = x[i] - '0';//别忘了------！！！
        		j--;
        	}
        	b[0] = y.length();j = b[0] ;
        	for (int i=0;i<y.length();i++) 
        	{
        		b[j] = y[i] - '0';
        		j--;
        	}
        	//模拟----将除法转为减法---补零+检查+减法
        	if(a[0] < b[0] || (a[0]==b[0] && x<y))  
        	{//小除大 -----特殊
        		cout << 0 << endl;
        		return 0;
        	}
        	c[0] = a[0] - b[0]+ 1;
        	for (int i = c[0];i>=1;i--) 
        	{//计算第i位 
        		int t[5005] = {0};
        		fill(t, b, i-1);//补零函数 
        		int cnt = 0; 
        		while (check(t, a))
        		{//如果减数a，大于补零转换后的t，实施减法
        			
        			sub(t, a);////substreat -----写个特别的高精度减法 ------------------3
        			cnt++; 
                    //减一次后，a改变 ，再与t判断能否接着减
        		}
        		c[i] = cnt;
        	}
        	//输出---别忘了去前导0
        	while (c[c[0]] == 0 && c[0] > 1  )c[0]--;
        	for (int i = c[0]; i>=1;i--)	cout << c[i];
        	cout << endl;
        	return 0;
        }
        ```


3、高精度总结

- 



# 贪心

1、数据结构中应用到贪心的思想

- 树——哈夫曼树的构建
- 图——最小生成树kruskal
- ​    ——最短路径Dijkstra

2、贪心：

- 是用计算机来模拟一个「贪心」的人做出决策的过程。这个人十分贪婪，每一步行动总是按某种指标选取最优的操作。
- 而且他目光短浅，总是<u>只看眼前</u>，并不考虑以后可能造成的影响。
	- 贪心思想将一个最优决策过程变成多步决策过程，并在每步总是做出**当前看来是最好的**选择
	- 它（贪婪的人）并不从全局最优上加以考虑，它的选择只是在某种意义上的<font color=red>局部最优选择</font>——不同于dp（全局整体最优）
- 可想而知，并不是所有的时候贪心法都能获得最优解，所以一般使用贪心法的时候，都要确保自己能证明其正确性。

题型：求最值最优解问题。

- 贪心思想解题，往往不重证明，感觉对，样例也能过，大概率就AC了

3、例题

1. [P1090 NOIP 2004 提高组\] 合并果子 - 洛谷](https://www.luogu.com.cn/problem/P1090)

  分析：进行n-1次合并的体力耗费值最小。

  - n个数两两合并的和最小——>每两个数合并的值尽可能小
  - 即每次合并两堆果子消耗的体力值尽可能地小——>
  - 每次合并重量尽可能小的两堆果子

  问题：如何去找到当前最小的两堆果子呢？在规定的时间内。

  - 每次合并后排序（升序），最前面两个就是最小的----排序O(nlogn),
    - 需要排n-1次，总：O(n* n * logn)，超时。


  - 可以用==优先队列（priority_queue）==，优先队列基于**堆**实现，找最小时间复杂度<font color=pink>O(logn)</font>，找n次，总：O(nlogn)。因此可直接用C++ STL的优先器

  注意：题目要求输出一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 2^31^ 。

  - 此时，int类型已经力不从心，需要使用long long来存储

  思路：根据贪心思想做出来的分析，使用优先队列来实现

2. [P4995 跳跳！ - 洛谷](https://www.luogu.com.cn/problem/P4995)

  分析：想消耗尽可能多的体力，则每次都选择高度差最大的俩快石头

  思路：

  - 包括地面（h~0~=0）在内，给所有石头按高度升序排列
  	- 借助cpp标准库中`sort(begin, end+1)`函数，<font color=red>指针类型左闭右开</font>
  - 使用双指针t、b，循环判断条件**b<t**
  - 左右横跳，更新t、b

  注意：

  - 每一次跳跃的体力值计算(h~i~−h~j~)==^2^==
  - 而 0<h~i~≤10^4^；对于 100% 的数据，*n*≤300。
  - ans的存储范围最大达到了300*10^8^，而int的存储范围-2^31^~2^31^-1，又经过换算：<font color=blue>2^31^ = 10^9.331109.331^≈10^9^</font>
  - 所以这里采用long long存储ans，<font color=red>因此题目所给的数据范围，需要去斟酌</font>
      - 用**printf**对long long类型输出，应使用<font color=red>%lld格式符</font>，cout则不需要

3. [2611. 老鼠和奶酪 - 力扣（LeetCode）](https://leetcode.cn/problems/mice-and-cheese/description/)

    分析（题意）：

    - n块奶酪都要吃完，同一块奶酪不同老鼠得分不同，第一只恰好吃k块，
        最大得分

    思路：

    - 先让第二支老鼠吃所有n块奶酪，然后分析如果第i块奶酪是给第一只老鼠吃，得分会更多，得分加reward1[i] - reward2[i]
    - 我们对reward1[i] - reward2[i]进行排序，选出差距（得分增值）最大的k块给第一只老鼠吃
    - 即可得到最大得分

    注意：

    - sort排序的区间，一定要画图理解清楚明白，否则在OI赛制下，只会被默默扣分



# 递归&分治

1.1、递归（英语：Recursion）

- 在数学和计算机科学中是指在**函数的定义中使用（调用）函数自身**的方法，在计算机科学中还额外指一种通过重复将<font color=red>问题分解为同类的子问题</font>而解决问题的方法。

难点：递归出口

- 难找、找不全

怎么写一个递归的代码？

- 1）找到递归出口
- 2）==确定问题--->解决基准问题--->拆解问题==
- 3）递归条件，试着用小范围样例推一推，站在第i个问题的角度去考虑，代码怎么写

注意：

- 不要陷入先有鸡还是现有蛋的困境
- 分析递归代的时间复杂度码要从思路着手分析

1.2、例题

1. [面试题 08.06. 汉诺塔问题 - 力扣（LeetCode）](https://leetcode.cn/problems/hanota-lcci/description/)

    分析：

    - 将最底层圆盘移出来，实现将上面n-1个圆盘移出来，而这个拆解出来的小问题也就是同样的情形，采用递归调用
    - 递归出口：但只有一个圆盘的时候，就可以直接移动过去
    
    切记：
    
    - <font color=red>写递归代码，不要去想它是怎么执行的，就想调用这次之后就执行完成了你想要的功能</font>
    
    理解：
    
    - 可以调试，观察具体过程
    - 可以输出每个圆盘的移动过程，传参char（3个柱子的编号）
        - <font color=blue>打输出也是一个调试技能</font>

2.1、分治：（英语：Divide and Conquer）

- 「分而治之」，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，<font color=red>子问题相互独立</font>，直到最后子问题可以简单的直接求解，<font color=red>原问题的解即子问题的解的**合并**</font>。------最优子结构性质。

2.2、二者区别

- 递归是一种编程技巧，一种解决问题的思维方式；分治算法很大程度上是基于递归的，解决更具体问题的算法思想。

- <img src="D:\Node-typora\note-picture\image-20250302104928026.png" alt="image-20250302104928026" style="zoom:33%;" />
- <img src="D:\Node-typora\note-picture\image-20250302110221046.png" alt="image-20250302110221046" style="zoom:33%;" />

2.3、例题

1. [53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/description/)

    分析：

    - 取区间中间值mid，最大连续和子数组只会出现在左区间、右区间、整个区间
    - <font color=red>分治以上三种情况</font>，前两种可以用**递归**来写，整个区间**另设计函数求解**
    - 最后整合

    思路：

    - 1.暴力：枚举起点和终点，计算区间内的和，取最大值。时间复杂度：O(n^2)

        2.分治：时间复杂度：O(nlogn)

        3.动态规划：线性动态规划。时间复杂度 O(n)。

    - **分治**：取中心点m=(l+r)/2。 和最大的区间要么出现在中心点左边，要么出现在中心点右边，要么**横跨中心点**。所以问题分解为求这三部分的最大区间和，然后取最大值。----分成3个独立的小问题，分治。

        (1) 中心点左边的最大区间和：和原问题相同，递归-----调用整个solve函数（包含求3的函数）。

        (2) 中心点右边的最大区间和：和原问题相同，递归。

        (3)横跨中心点的最大区间和：贪心求解---**从中心点往左右两边延申**。

           从中心点不断往左延申，同时记录最大值lmax

          从中心点不断往右延申，同时记录最大值rmax

          <font color=red>横跨中心点的最大区间和：lmax+rmax</font>

    注意：

    - 左右半边的右左边界不能使用同一个mid，新左[l, mid]，新右[mid+1, r]

2. 样例

    - <img src="D:\Node-typora\note-picture\image-20250414143010112.png" alt="image-20250414143010112" style="zoom: 25%;" />

        往恰好缺一个格子的n*n（偶数）棋盘中，填入这种L形状的地砖，需要多少个可以将其铺好

    - 分治思想：

        - 1.从中间对地板划十字。<img src="D:\Node-typora\note-picture\image-20250414143413976.png" alt="image-20250414143413976" style="zoom:25%;" />
        - 2.将一个L形地砖放在没有缺的三块分割区域
        - <font color =red>这样，对于每个划分区域就变为了原来的相同子问题</font>
            - 递归操作1.2步骤



# 链表

- 分清楚题目中所给的链表是否带<font color=red>头节点</font>

继数据结构，补充内容：静态链表、跳表

1、链表常用思路：

- 遍历模拟
- <font color=red>快慢指针思想</font>：根据具体题目去定义快慢

2、例题

1. [206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/description/)

    分析：

    增加难度：**原地**反转（置）

    思路1：头插法的应用

    - 头插法建立起来的链表是倒序的
        - 若带头结点，先将头结点摘下。
    - 开==标记指针p，t==，然后从第一个结点开始，挨个摘下每一个结点，摘下后用头插法建立新的链表

    思路2：双（三）指针法

    - 定义两个指针==p==、==q==，p在前，q在后
    - 每次让p的next指向q，实现一次局部反转
    - 局部反转完成后，p、q同时往前移动一个位置
        - 期间使用临时指针==t==保存p->next防止后续链表的丢失
    - 循环，直至p为NULL

    思路3：递归

2. [LCR 140. 训练计划 II - 力扣（LeetCode）](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/description/)

    分析：

    思路1：

    - **遍历一遍**，计算该单链表的所有节点数n，**再次遍历**到n-cnt+1，输出
        - 注意：这里是<font color=red>单链表，不可以倒着遍历</font>

    思路2：快慢指针

    - 分别定义两个快慢指针f、s
    - f指针先走cnt-1步
    - 然后f、s指针一起走
    - **遍历一遍**，当f走到最后一个节点，输出s指向的节点数据

3. [142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/description/)

    分析：判环，返回环的入口
    
    思路1：
    
    - 打标记，如果将走过的节点标记为1
    - 如果循环走到了已经标记过的节点，则是环的入口
        - 力扣链表节点结构已经给出，可能**不适用**
    
    思路2：快慢指针
    
    - 整两快慢指针f、s
    
        - ```cpp
            if (f->next == NULL)
            {//避免空间的泄露
                return NULL;
            }
            f = f->next->next;
            ```
    
    - f走两步、s走一步，如果有环，f先进入环，s后进入环
    
    - s进入环后，<font color=red>f会在s走**一圈内**追上s</font>，与s在某节点相遇<img src="D:\Node-typora\note-picture\qq_pic_merged_1741169962300.jpg" alt="qq_pic_merged_1741169962300" style="zoom:25%;" />
    
    - 再整s指针，从起点出发，原s指针从相遇点出发
    
    - <font color=red>二者相遇的节点位置就是环的入口</font>
    
    思路2背后的数学理论支持：
    
    - <img src="D:\Node-typora\note-picture\qq_pic_merged_1741169480002.jpg" alt="qq_pic_merged_1741169480002" style="zoom: 50%;" />



3、补充内容

1. 静态链表：用数组描述的链表，即称为静态链表

    - 分配一整片连续的内存空间，各个结点集中安置，逻辑结构上相邻的数据元素，存储在**指定的**一块内存空间中，数据元素只允许在这块内存空间中**随机存放**
        - <img src="D:\Node-typora\note-picture\image-20250305173405288.png" alt="image-20250305173405288" style="zoom: 25%;" />被此空间框住，在此空间内实现物理上的不连续

    - 这样的存储结构生成的链表称为静态链表。也就是说静态链表是用数组来实现链式存储结构，静态链表实际上就是一个结构体数组。
        - <img src="D:\Node-typora\note-picture\image-20250305173458912.png" alt="image-20250305173458912" style="zoom:25%;" />

2. 跳表：又叫做跳跃表、跳跃列表，在有序链表的基础上增加了“跳跃”的功能

    - 如果一个数组是有序的，查询的时候可以使用**折半查找**，时间复杂度可以降到 O(logn) 。但如果链表是有序的，也不可以使用二分，我们仍然需要从前往后一个个查找，这样显然很慢，这个时候我们可以使用跳表（Skip list）
    - 跳表就是多层链表，每一层链表都是有序的，最下面一层是原始链表，包含所有数据，从下往上节点个数逐渐减少。
    - <img src="D:\Node-typora\note-picture\image-20250305175231686.png" alt="image-20250305175231686" style="zoom:50%;" />

    跳表的特性：

    1. 一个跳表有若干层链表组成；

    2. 每一层链表都是有序的；
    3. 跳表最下面一层的链表包含所有数据；
    4. 上一层的元素指向下层的元素必须是相同的；
    5. 头指针 head 指向最上面一层的第一个元素；



# 栈和队列

 1、栈的应用及题目：

- 注意：做题时，多数使用<font color=red>数组直接模拟栈(队列) </font>或者 直接用C++ ==STL中的stack（queue）==

- 括弧<font color=blue>左右匹配类问题</font>：while左括弧，入栈，遇到右括弧，弹出栈与之匹配

2、例题

1. [P4387 【深基15.习9】验证栈序列 - 洛谷](https://www.luogu.com.cn/problem/P4387)

    分析：模拟，按照它的出栈要求出入栈

    思路：

    - 按入栈顺序入栈，如果**栈顶元素**与出栈序列的元素相同，就将其弹出
    - 每压入栈**第i个元素**后，判断（<font color=red>注意用while判断，因为可能连续弹出</font>），栈空不出栈
        - “stack”中的栈顶元素是否和出栈序列中的**第j个元**素一致（栈为空就不用判断了）如果一致则弹出栈顶元素，<u>j++</u>；
        - 如果不一致则继续压入入栈序列中的<u>第i+1个元素</u>。
    - 继续判断
    - 最后如果“stack”为空或指针j到达出栈序列的末尾就输出Yes，否则输出No

    **另**：注意：防骗分

    - 对下一个样例进行操作前，需要将 pushed 和 poped 两个序列重新初始化

        - ==使用`C`的头文件`<cstring>`中包含的`memset( )`函数==

        - 函数原型

            ```c
            #include <cstring>  
            void* memset(void* s, int c, size_t n);  
            ```

            - `void* s`：指向要填充的内存区域的指针（数组名）。
            - `int c`：要填充的字符值。实际上，`c` 会被转换为 `unsigned char`，因此只考虑其低 8 位。
            - `size_t n`：要填充的字节数。

            实例：

            ```cpp
            int arr[5];  
            memset(arr, 0, sizeof(arr)); // 将所有元素初始化(重置)为0 
            ```

            ```cpp
            struct Data {  
                int a;  
                char b[10];  
            };  
            Data d;  
            memset(&d, 0, sizeof(Data)); // 将整个结构体重置为0  
            ```

            注意：

            - 使用`sizeof`来计算填充的字节数大小
            - 总结来说，`memset` 是一个强大的低级函数，用于快速填充内存区域，但需谨慎使用，尤其是在处理敏感数据时，应该考虑使用更安全的替代方案

    - 当上一个样例输出No时，此时的栈可能还有残余的顽固元素，所以在对下一个样例进行操作前，将栈清空

    ==小技巧==：

    - ```cpp
        while (n--)//执行n次 
        ```

    时间复杂度：O(q * 2n) , 即O(q * n)

2. [735. 小行星碰撞 - 力扣（LeetCode）](https://leetcode.cn/problems/asteroid-collision/description/)

    分析：

    - 数组中小行星的**索引**表示它们在空间中的相对位置。即a[0]号行星在a[1]号行星的左边
    - 这就属于是<font color=blue>左右匹配类问题</font>

    思路：

    - 模拟所有可能，相邻两行星
        - +、+
        - -、-
        - -、+：左行星向左走，右行星向右走，以上三种均不会发生碰撞
        - +、-：==Boom！！！==
    - 使用不定数组来模拟栈
        - ve[0]作为栈底
        - ve.back()：查看栈顶
        - ve.push_back()、pop_back()：入栈出栈
    - 可以入栈的情况
        - 栈空
        - 行星为正+（行星向右移动，一定不会与栈内行星发生碰撞）
    - 判断待入栈行星和栈顶行星是否会发生碰撞，因可能会连续碰撞，所以使用while循环
        - 行星为负-，查看栈顶，栈顶行星也为负数，可以入栈，不会boom
        - 栈顶行星为正，发生boom，比较判断boom后栈情况

# 单调栈

单调栈：栈中的元素是严格单调递增或者递减的，也就是说：**从栈底到栈顶**，元素的值逐渐增大或者减小。

- 多用于求解元素的左右大小边界问题：
    1. 向左找第一个比自身大的数。---- 向左找，第一个<font color=red>待入栈元素</font>作为研究对象
        - 与栈顶元素比较，需要栈内弹出元素，即是
    2. 向左找第一个比自身小的数。
        - 与栈顶元素比较，可以直接入栈，既是
    3. 向右找第一个比自身大的数。---- 向右找，<font color=red>栈顶元素</font>作为研究对象
        - 与待入栈元素比较，可以直接入栈，既是
    4. 向右找第一个比自身小的数。
        - 与待入栈元素比较，需要自身弹出的，既是

操作（**以底到顶**递**增**为例）

- 如果新的元素比栈顶元素大，就入栈
- 如果新的元素较小，那就一直把栈内元素弹出来，直到栈顶比新元素小

图示：

- 

1、例题

1. [P5788 【模板】单调栈 - 洛谷](https://www.luogu.com.cn/problem/P5788)

    分析：

    - 单调栈模拟。向右找第一个最大的数，并返回下标

    思路：对数据，从右往左入栈模拟

    -  使用下标`i`入栈，数据`a[i]`比较大小



# 二叉树相关题目

二叉树的题目多是基于递归的

- ```cpp
    f(root)//函数：要对以root为根的二叉树做一些操作或判断
    {
        //递归边界
        //递归体
        if(root//？？？？)
        {
            f(root->left);
            f(root->right);
        }
    }
    ```

- 递归：递归出口、递归体、完成任务返回

1、例题

1. [LCR 145. 判断对称二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/description/)

    分析：

    - 空树一定对称。左右子树根节点相同
    - 左子树的右子树与右子树的左子树镜像对称------左右==右左（内八对称）
    - 左子树的左子树与右子树的右子树镜像对称------左左==右右（外八对称）

    思路：

    - 根据二叉树的性质5进行**递归**建树
    - 考虑空树的情况
    - 另写一个check函数，将根节点root的左右节点p、q传入
        - 这里的两个指针就来自彼此的镜像对面
    - 递归调用：p->val == q->val && check(p->l, q->r) && check(p->r, q->l)



# 种类并查集

并查集：用来处理一些不相交**集合**的**合并**和**查询**的问题

- 种类并查集（扩展域并查集）

1、例题

1. [P3367 【模板】并查集 - 洛谷](https://www.luogu.com.cn/problem/P3367)

    分析：1为合并操作、2为查找操作

    疑问：

    - 为啥==初始化`f[i] = i`==，初始元素不是1、2、3……这些也是这样吗？

        **答**：`f[i] = i` 的初始化是并查集算法的设计核心，与元素具体编号无关。它确保了每个集合的独立性和操作的正确性，是后续合并（Union）与查询（Find）操作的基础

    思路：模板题

    注意：

    - 需要使用==find函数==去找元素的根节点，而不是f[i]，这只是判断是否为单元素集合
        - 找到根节点后，可以同时实现==路径压缩==

2、种类并查集

- 并查集：能维护连通性、传递性，通俗地说，亲戚的亲戚是亲戚-----美好的事物

    - 当我们需要维护一些<font color=red>对立关系</font>，比如 敌人的敌人是朋友 时，正常的并查集就很难满足我们的需求。
    - 种类并查集就诞生了

- 做法：将原并查集扩大一倍规模，并划分为两个种类：

    - 其中[1，n]表示处于一个种类-----之间存在两种对立关系（朋友敌人）
    - [n+1, 2n]表示处于另一个种类------（[1， n]的对立）。<font color=red>假想敌</font>
        - eg：1的假想敌就是1+n，30的假想敌就是30+n
            - 能用两个数组表示假想敌和朋友嘛？------不能，下标i表示的i人

    维护xy朋友关系：一次**合并x、y所在树**（原并查集操作，一个集合里的元素互为朋友）

    维护xy敌人关系：两次合并

    - x与y的**假想敌y+n**合并
    - y与x的**假想敌x+n**合并

    图示：<img src="D:\Node-typora\note-picture\image-20250311162152021.png" alt="image-20250311162152021" style="zoom: 33%;" />

- 按照并查集美妙的传递性，我们就能具体知道某两个元素到底是 敌人 还是 朋友 了（潜在）

3、例题

1. [P1525 NOIP 2010 提高组\] 关押罪犯 - 洛谷](https://www.luogu.com.cn/problem/P1525)

    分析：最小化最大值

    思路：

    - 按火气值，从大到小的顺序依次分配罪犯
        - sort函数，排序方式的重写

    - 能合并，就进行两次合并
    - 不能，就说明在之前的合并操作后，二者已经在一个集合里了，此时他俩的冲突值既是答案
        - 另外，二者的天敌在同一个集合也`&&`不能合并，返回

    技巧：

    - 使用==结构体==存储二者之间的关系和火气值

    注意：

    - 题目要求的特殊情况，需要照顾到

2. 题目：食物链

    分析：3个种类

4、并查集出题思路

- 并查集与其他算法结合
- 出种类并查集



# 搜索

- 搜索: 也就是对状态空间进行枚举，通过穷尽所有的可能来找到最优解，或者统计合法解的个数。
- 搜索有很多优化方式，如减小状态空间，更改搜索顺序，剪枝等。
- 搜索分为：DFS 和 BFS

## DFS

DFS(图论)：深度优先搜索,是一种用于**遍历或搜索树或图**的算法。所谓深度优先，就是说每次都尝试向更深的节点走----一条路走到黑。

在 搜索算法 中，该DFS常常指 **利用递归函数**方便地实现暴力枚举的算法，与图论中的 DFS 算法有一定相似之处，但并不完全相同。通常是：<font color=red>构造一棵搜索树（或说是状态树）来进行搜索。往往+回溯</font>

1、例题

1. [P1706 全排列问题 - 洛谷](https://www.luogu.com.cn/problem/P1706)

    分析：字典序1 ~ n，A ~Z，位置相同再比下一位

    - eg：a<b,  aa < ab,  **b**dgfasdfaf<**c**

    思路

    - 构造一棵搜索树（或说是状态树）来进行搜索。同时用数组来存放搜索树中的结果。
        - <img src="D:\Node-typora\note-picture\image-20250312202240262.png" alt="image-20250312202240262" style="zoom: 33%;" />
        - 这里先定义两个数组，一个是用来存放**合法解（答案）**---合法即输出，一个是用来**标记**该数是否用过
    - <font color=blue>回溯</font>---更新恢复到之前的状态（标记数组）
    - 输入n个数，依次填入n个位置，填入第k个，更新标记，递归调用填入k+1个
        - 递归实现后往回返（需要回溯），还原标记

    注意：

    - 输出---每个数字保留 5 个场宽------<font color=red>`%5d`</font>

    - ```cpp
        voie dfs(int k)
        {//选数填入第k位置
            ans[k] = i;//第k位置选择了
        }
        ```

    缺点：时间复杂度高。本质也属于是一种**枚举**（答案可以枚举出来）

     代码：

    - ```cpp
        #include <iostream>
        #include <cstdio>
        using namespace std;
        int n;
        int a[11], flag[11];//标记数组i位置是否使用，1使用，0未使用 
        void dfs(int pos)
        {//填第pos个位置为x; pos:1~n
        	if (pos > n)
        	{//填好了 
        		for (int i=1;i<=n;i++)
        			printf("%5d", a[i]);
        		printf("\n");
        		return;
        	}
        	//填下一个位置 ----枚举下一个位置可能填入的所有值+记忆化搜索
        	for (int i=1; i<=n; i++)
        	{
        		if (flag[i]==0)//未使用 ---记忆化
        		{
        			a[pos] = i;
        			flag[i] = 1;
        			dfs(pos+1);
        			flag[i] = 0;//回溯 
        		}
        	}
        }
        int main()
        {
        	cin >> n;
        	dfs(1);//填第一个位置
        	return 0; 
        }
        ```

    <font color=blue>感悟：</font>

    - 对**是否访问过**元素，进行**打标记**辨别------<font color=red>记忆化搜索</font>
    - 枚举下一个位置的填入的所有可能---找准来
    - **dfs搭配回溯**操作的底层逻辑（搜索树）

2. [200. 岛屿数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-islands/description/)

    分析：

    - 在 搜索算法 中，DFS也常被用于 在**网格(行和列)中搜索**，搜索过程中考虑往4个或者8个方向（允许斜着走）搜索，同时要注意不要越过网格的边界。

    思路：

    - 主循环：遍历整个矩阵。
        - 当遇到一点为‘1’时说明遇到了一个岛屿，岛屿数目+1。
        - 但是这个‘1’只是岛屿的一部分，所以要通过 **DFS来搜索到整个岛屿**，并把这个岛屿的值全改为0，防止重复计算答案。
    - DFS：设目前在（i,j）点，搜索（i，j）所在的整个岛屿。
        - 从（i，j）向**上下左右**四个方向进行搜索 （i+1,j）(i-1,j) (i,j-1) (i,j+1)。
        - <font color=red>若这4个点为‘1’，且不越界</font>，则可以走过去，然后将走到的点的值改为‘0’，再以走到的点为基础进行搜索
        - 走不过去，就return返回到上一个基础点

3. 题单：视频末尾

==2、大致模板==

- <img src="D:\Node-typora\note-picture\404fd3a43ab263531d7bac42891df1aa.png" alt="404fd3a43ab263531d7bac42891df1aa" style="zoom: 67%;" />

- ```cpp
    function dfs(当前状态){
    	if(当前状态 == 目的状态){
            ···
        }
        for(···寻找新状态){
            if(状态合法){
                vis[访问该点]；
                dfs(新状态);
                ?是否需要恢复现场->vis[恢复访问]
            } 
        }
        if(找不到新状态){
            ···
        }
    }
    ```

**3、总结**

- DFS图论：树和图的遍历

- 基于搜索树（状态树）的枚举题目

- 基于表格搜索

    均为跳过dfs找到所有的可能

## BFS

BFS(图论)：广度优先搜索,是一种用于遍历或搜索树或图的算法。所谓广度优先，就是说按照**圈层次**搜索

- 在 搜索算法 中，该BFS常常指 利用<font color=red>队列实现广度优先搜索</font>，从而寻找最短距离。与图论中的 BFS 算法有一定相似之处，但并不完全相同。通常用来解决 寻找最短距离的问题。
- 在 搜索算法 中，BFS也常被用于**在网格中搜索，找最短距离**。搜索过程中考虑往4个或者8个方向搜索，同时要注意<u>不要越过网格的边界。</u>

1、例题

1. [P1443 马的遍历 - 洛谷](https://www.luogu.com.cn/problem/P1443)

    分析：这里的指的是象棋中马走日的🐎，出题人以为大家都知道呢，硬是不交代一下

    思路：<font color=red>寻找网格中一点到其他点的最短距离，显然用BFS</font>

    - 将所有位置初始化为-1，BFS结束后，仍为-1说明就是不能到达

        - 这里还可以作为判断条件`ans[i][j]>-1`，成立说明**没有遍历过**，可以更新值，就可以不开**访问数组**

        - <font color=red>ans数组更新，第几层遍历到的就更新为几</font>，实现：

            - ```cpp
                ans[next.x][next.y] = ans[now.x] [now.y]+1;//叠加
                //由上一层遍历而来，+1即可
                ```

            - 另外一种实现方式：idx记录现在正在进行第几层遍历，idx=几，更新为idx即可

    - “日”字的八个方向，可以通过对行列坐标 x y做加减dx dy得到：

        - 开偏移量数组记录下一步坐标：在草稿上就可以全部模拟出来---所以打草稿还是很重要的

        <img src="D:\Node-typora\note-picture\image-20250315153103016.png" alt="image-20250315153103016" style="zoom:50%;" />

    - 队列用STL实现，进行BFS，过程中要维护距离数组

2. [P8693 蓝桥杯 2019 国 AC\] 大胖子走迷宫 - 洛谷](https://www.luogu.com.cn/problem/P8693)

    分析：

    - 求小明从起点走到迷宫终点的最少时间，用==广度优先搜索算法 BFS==

    - 起点设置在了第 3 行第 3 列（3，3）从1开始存储，终点设置在了第 *n*−2 行第 *n*−2 列。

    思路：

    - 小明有5种行进选择（上下左右，外加不动），上下左右可以整个**dx、dy**数组
    - 结构体pos记录小明**何时(time)**到此位置x，y
        - time==k，小明从大大胖子瘦身为大胖子
        - time==2k，瘦身为正常人
    - **flag**标记小明的胖瘦
        - flag = 2，小明占5*5 ------【x-flag，y-flag；x+flag，y+flag】
        - flag = 1，小明占3*3
        - flag = 0，小明占1*1
    - 小明行进到next位置，需要**for循环遍历判断是否能走**---小明占地不越界&&无障碍

    注意：

    - 小明一开始无需原地逗留，直接走到样例中那样的关卡点，可以逗留等待瘦身，便于通过。-----<font color=red>错误思想×</font>
    - <font color=blue>正确√</font>：小明在还没有瘦成一个正常人时（flag!=0），都可以选择战术性原地逗留
        - next = now，但时间next = now.time**+1**
        - 另外继续将**该位置（原地）**入队
        - 也可以==继续==试图按上下左右四个方向访问，时间花销是一样的
    - 最终的答案即到达位置[n-2, n-2]的**时间time**



## 优化

搜索: 也就是对**状态空间（答案）**进行枚举，通过穷尽所有的可能来找到最优解，或者统计合法解的个数。但是DFS其时间复杂度特别高，因为DFS本质上还是暴力枚举答案。

搜索有很多优化方式，如减小状态空间，记忆化搜索等，统称为**剪枝**。无论是何种优化方式，其本质都是<font color =red>想办法减少对不合法及重复的答案 的枚举。</font>

- **剪枝**可以笼统的分为两大类：最优性/可行性剪枝、记忆化搜索。

1、例题

1. [P1025 NOIP 2001 提高组\] 数的划分 - 洛谷](https://www.luogu.com.cn/problem/P1025)

    分析：DFS+剪枝

    思路：

    - 剪枝1：不考虑顺序，采用**升序（不降）枚举，排重**
        - 记录每一次划分：<font color=red>记录上一次划分所用的数，保证当前划分所用数**不小于**上次划分所用分数，</font>
        - 当划分次数等于k时，得到可行解，比较该次划分**所得分是否与n相同**并记录次数（与k比较），得到答案解
    - 剪枝2：搜索过程中，划分所得分**已经大于n**了，直接剪掉
        - 所以枚举过程划分sum小于等于n，即可停止接着枚举
    - 图示：<img src="D:\Node-typora\note-picture\8a6584548bd972330a11f55060d77f59_720.png" alt="8a6584548bd972330a11f55060d77f59_720" style="zoom: 50%;" />
    - **高级剪枝（2升级版）**：（1+2结合一下）：<img src="D:\Node-typora\note-picture\e028a37172f2fa65f9d60eb0329c9419_720.png" alt="e028a37172f2fa65f9d60eb0329c9419_720" style="zoom:33%;" />

    注意：

    - 需要高级剪枝和剪枝1、2结合起来，<font color=red>放在**for循环里**的初始条件和判断条件</font>
    - ==`sum + i * (k - idx) <= n`==，减少for循环遍历次数（真·剪枝），才会不超时

2. [P1464 Function - 洛谷](https://www.luogu.com.cn/problem/P1464)

    分析：记忆化搜索，dp的备忘录写法

    思路：

    - dp[a] [b] [c]记录w(a,b,c)函数的值

    注意：

    - 在输入中可能存在负数，如果一开始的判断语句只写if（dp[x] [y] [z]）就炸了（因为不能访问数组负数下标），因此**需要加一个特判**

# 图的存储--链式前向星











# 动态规划

动态规划初探----数据结构及算法篇

- 动态规划DP做题步骤：
    1. 确定状态：即找到状态数组。
        可以**尝试**用一句话来描述问题，其中涉及到的<u>参数就是状态数组的下标</u>
    2. <font color=red>确定**状态转移方程**--------**递推公式**那股味</font>
        一般化：举例子
        找第i个状态，默认<u>前面1~i-1状态[^7]</u>已经给出
    3. 初始化状态数组：即找到初始状态（分析题意得知）
    4. 写状态转移部分代码
    5. 输出题目要求的状态

## 线性DP

1、线性动态规划：（线性DP）是具有线性阶段划分的动态规划算法，也称线性DP。若状态包含多个维度，则每个维度都是线性划分的阶段，也属于线性DP

- **dp[i] = operate{dp[i-1], dp[i-2], ...}**

2、经典例题：

- 序列问题：最长上升子序列，最长公共子序列LCS
    - ==最值问题：二分？贪心？dp？==
- 最短编辑距离问题
- 其他

3、例题

 1. [B3637 最长上升子序列 - 洛谷](https://www.luogu.com.cn/problem/B3637)

    分析及思路：

    - <font color =red>dp[i]=x：表示**以a[i]结尾**的最长上升子序列的长度为x</font>

        > 从前i个元素中找到以a[i]结尾的最长上升子序列，dp[i]表示该序列的长度

    - 答案：max(dp[1] ~ dp[n])

        - **易混淆点**：最长上升子序列结尾的元素不一定是最后一个元素，所以答案就不是肤浅的dp[n]

    代码：

    - ```cpp
        #include <iostream>
        #include <algorithm>
        using namespace std;
        int dp[5005], a[5005], n;
        int main()
        {
        	cin >> n;
        	for (int i=1; i<=n; i++){
        		cin >> a[i];dp[i] = 1;//自身长度就是1个上升子序列
        	}
        	for (int i=1; i<=n; i++) 
        	{
        //		int maxlen = 0;//原理-----有点看不懂了哈
        //		for (int j=1; j<i; j++){
        //			if (a[j] < a[i]) maxlen = max(maxlen, dp[j]);
        //		}
        //		dp[i] += maxlen;//本身长1
        		for (int j=1; j<i; j++)
        		{
        			if (a[j] < a[i]) dp[i] = max(dp[i], dp[j]+1);//状态转移方程
        		}
        	}
        	int ans = 0;
        	for (int i=1;i<=n;i++)dp[i]>ans?ans=dp[i]:0;
        	cout << ans << endl;
        	return 0;
        }
        ```

    感悟：

    - 刷新初识==状态转移方程==的形式：`dp[i] = max(dp[i], dp[j]+1)`
        - 初识以为全是简单的递推方程

 2. [LCR 095. 最长公共子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/qJnOS7/description/)

    分析及思路：

    - 求最长公共子序列（LCS，**不要求连续**），最值问题考虑？---此题用dp
    - 该怎么做？---找状态数组
    - 如何找？---描述问题
        - 一句话描述问题：求出 第一个序列`text1`(下标1 ~ L1)与第二个序列`text2`(1 ~ L2)的公共子序列。
        - 即求出第一个序列的以`L1`结尾的子串与第二个序列的以`L2`结尾的子串的公共子序列。
        - <font color=red>得到状态数组</font>：`dp[i][j]`:表示text1以下标i结尾的子串与text2以下标结尾的子串的LCS
    - 写状态转移方程。怎么写？
        - <font color=red>默认认为dp[i-1] [j-1], dp[i-1] [j], dp[i] [j-1]都是已知的</font>
        - 对于已知的dp[i-1] [j-1]，求dp[i] [j]相当于在两个子串右边都新增一个字符
            - 如果两个字符相同，则`dp[i][j] = dp[i-1][j-1] + 1`
            - 不相同，则考虑继承前面子串的LCS，则`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`
        - get it
    - 初始化状态数组---考验技术的时候到了，ob仔细不🐕
    - 夸夸一顿敲

    代码：

    - ```cpp
        #include <iostream>
        #include <algorithm>
        #include <string>
        using namespace std;
        int dp[1005][1005];
        string t1, t2;
        int main()
        {
        	cin >> t1 >> t2;
        	t1 = 'A' + t1;//注意'A' 放前面，占据下标0 
        	t2 = 'A' + t2;//将有效子串下标从1开始(防越界)，结尾仍为size-1
        	for (int i=1; i<=t1.size()-1; i++)
        	{
        		for (int j=1; j<=t2.size()-1; j++)
        		{
        			if(t1[i] == t2[j])
                        dp[i][j] = max(dp[i][j], dp[i-1][j-1]+1);
        			else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
        		}
        	}
        	cout << dp[t1.size()-1][t2.size()-1] << endl;
        	return 0; 
        }
        ```

    感悟：

    - 动态规划的美妙~

 3. [P2758 编辑距离 - 洛谷](https://www.luogu.com.cn/problem/P2758)

    分析及思路：

    - 找状态数组：
        - 类似上一题：dp[i] [j]：<u>以i结尾的子串1</u>转换成<u>以j结尾的子串2</u>，最少操作次数
    - 找状态转移方程：
        <font color=red>默认认为dp[i-1] [j-1], dp[i-1] [j], dp[i] [j-1]都是已知的不要多想，就是自下往上推（不同于递归），假设就是已知的，做好初始化，拿来用就行了</font>
        - 知道dp[i-1] [j-1]：
            - 当第i、j个字符**相同时**，继承dp[i-1] [j-1]的操作次数即`dp[i][j] = dp[i-1][j-1]`
        - **不相同时**，可通过三种情况得到dp[i] [j]
            - `dp[i][j-1]`：以i结尾的子串1<u>删除操作</u>一个字符得到以j-1结尾的子串2，即`dp[i][j] = dp[i][j-1] + 1`;
            - `dp[i-1][j]`：以i-1结尾的子串1<u>插入操作</u>一个字符得到以j结尾的子串2，即`dp[i][j] = dp[i-1][j] + 1`;
            - `dp[i-1][j-1]`：以i-1结尾的子串1<u>修改操作</u>一个字符得到以j-1结尾的子串2，即`dp[i][j] = dp[i-1][j-1] + 1`;
        - ==应本题要求，对这三种情况进行取min==
    - 初始化状态数组
        - 检验你是糕手还是小垃圾-----事实证明我是大垃圾🆘
    - 畏手畏脚地敲代码

    代码：

    - ```cpp
        #include <iostream>
        #include <algorithm>
        #include <string>
        using namespace std;
        int dp[2005][2005];
        string A, B;
        int main()
        {
        	cin >> A >> B;
        	A = 'B' + A;B = 'C' + B;//1下标开始，防越界
        	//初始化 
        	for (int i=1; i<=A.size()-1; i++)
                dp[i][0] = i;//将子串1全部删掉，变成空串2 
        	for (int j=1; j<=B.size()-1; j++)
                dp[0][j] = j;//对空串1一直插入字符，变成子串2 
        	for (int i=1; i<=A.size()-1; i++)
        	{
        		for (int j=1; j<=B.size()-1; j++)
        		{
        			if (A[i] == B[j])dp[i][j] = dp[i-1][j-1];
        			else
        			{
        				dp[i][j] = min(dp[i-1][j-1]+1, min(dp[i-1][j]+1, dp[i][j-1]+1));
        			}
        		}
        	}
        	cout << dp[A.size()-1][B.size()-1] << endl;
        	return 0;
        }
        ```

    感悟：

    - 动态规划求最优解的奥妙，本大垃圾的dp之旅正式开启

    - 动态规划的核心三部曲：

        - 1.状态数组：

            找到的状态数组结合每一个下标，**表达的含义**符合逻辑，**依据这个含义**帮助第3步的初始化

        - 2.状态转移方程（一套组合操作，含判断，含取最值）

        - 3.初始状态数组：<font color=red>可以重点通过**分析转移方程所需要的前置状态**来做到正确的初始化</font>



## 区间DP

1、区间dp：就是对于**区间**的一种动态规划，它**将问题划分为若干个子区间**，并通过<u>定义状态</u>和<u>状态转移方程</u>来求解每个子区间的最优解，通过合并（怎么划分的就怎么合并），最终得到整个区间的最优解。

- 区间：<img src="D:\Node-typora\note-picture\image-20250513120312391.png" alt="image-20250513120312391" style="zoom: 33%;" />

- 对于某个区间，它的合并/划分方式可能有很多种，我们需要去枚举所有的方式，通常是去枚举区间的分割/合并点，找到最优的方式(一般是找最少消耗)。

2、核心思路：状态（数组）dp[i] [j]：表示<u>下标i到j的区间</u>的最小消耗/最优解

- 步骤：
    1. 划分区间：首先**枚举划分区间的长度**
        - 对于划分出该长度的区间还要进行分割再计算合并，长度为1不用划分（会在区间分割时体现），所以<u>从长度2开始枚举</u>
    2. 然后**枚举左端点**，根据区间长度保证右端点不越界
        - 右端点为`left+len-1`
    3. 根据这个区间的左右端点，再**枚举这个区间的分割/合并点**
        - eg：枚举的区间长度为3，从2~4，则分割点就有2个为2、3

- 图示：

    - <img src="D:\Node-typora\note-picture\screenshot-1747111169199.png" alt="screenshot-1747111169199" style="zoom: 67%;" />

- 代码模板：
    由下至上，长区间肯定由短区间转移得到，所以先算短区间

    - ```cpp
        for (int len=2; len<=n; len++)
        {//枚举由两小区间合并而来的较大区间的长度 
            for (int i=1; i+len-1<=n; i++)
            {//枚举这个较大区间的左端点
                int j = i+len-1;//右端点，不要越界
                for (int k=i; k<j; k++)
                {//枚举合并点k
                    dp[i][j] = 最优|min(dp[i][j], dp[i][k]+dp[k+1][j]+合并消耗cost);
        }}}
        ```

    - 时间复杂度显然就是O(n^3^)

3、例题

1. [P1775 石子合并（弱化版） - 洛谷](https://www.luogu.com.cn/problem/P1775)

    分析：

    - 求最小代价？最小？最值问题？二分？贪心（与之前的合并果子不同）？dp？
    - 使用**区间dp**。合并石子的消耗为两堆石子的重量之和，可以通过**前缀和优化**避免for循环
        - 先由上往下分析：全部合并到一堆是由两堆小区间合并而来，而这两堆小区间是由更小的两个区间合并而来------大问题分解成小问题
        - 由下往上求解：得到前置状态，往上求解，最终得到一个整的大区间
    - 区间dp板子题-----做好初始化哟~

    代码：

    - ```cpp
        #include <iostream>
        #include <algorithm>
        #include <cstring>
        using namespace std;
        int dp[305][305];
        int m[305], sum[305];//前缀和优化 
        int main()
        {
        	int n; cin >> n;
        	memset(dp, 0x3f, sizeof(dp));//初始化---先
        	for (int i=1; i<=n; i++)
        	{
        		cin >> m[i];
        		sum[i] = sum[i-1] + m[i];
        		//后
        		dp[i][i] = 0;
        		//i==1?0:dp[i-1][i] = m[i]+m[i-1];
        	}
        	for (int len = 2; len<=n; len++)
        	{//枚举由两小区间合并而来的较大区间长度 
        		for (int i=1; i+len-1<=n; i++)
        		{//枚举较大区间的左端点 
        			int j = i+len-1;//右端点
        			for (int k=i; k<j; k++) 
        			{//枚举合并点 
        				int cost = sum[j] - sum[i-1];
        				dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + cost);
        			}
        		}
        	}
        	cout << dp[1][n] << endl;
        	return 0;
        }
        ```

    感悟：

    - 板子题也能学到东西，认真对待喵~

2. [P4170 CQOI2007\] 涂色 - 洛谷](https://www.luogu.com.cn/problem/P4170)

    分析：

    - 一个大写字母就表示一种颜色，不用纠结对应哪个颜色字母
    - 一眼求最值，答案范围肯定在[1，n]，二分？贪心？**无从下手**
    - 喵喵的没有一点思路，淦！<font color=red>**那就小范围推理一下把**</font>，从板子长度为1、2、3……
        - 木板长度为1：A型，只有一种颜色，涂一次
        - 板子长度为2：
            - AA：涂1次。**求最少次数**：可以转化为涂板长为1的最少次数
                	----（这里其实目标颜色首尾相同）
            - AB：涂2次。可以转化为涂两个板长为1的最少次数之和
        - 板子长度为3：---dp特征显露
            - AAA：涂1次。转化涂板长为1的次数
            - AAB、ABB：涂2次。分别转化涂两个：2+1，1+2的最少次数之和
            - ABA：涂2次。<font color=red>首尾涂色相同，可以一笔涂掉，再涂中间</font>
                - 即转化为涂BA或AB的最少次数之和。对二者取min
                - 也就是<u>一个丢掉首，一个丢掉尾</u>来涂。二者取min即为涂ABA的最少次数
            - ABC：涂3次。首尾涂色不相同，可以==划分==成两块板子AB+C或A+BC
                - 对二者最少次数之和再取min，即为涂ABC的最少次数
    - 得到dp思路

    思路：

    - 状态数组**dp[i] [j]**：板子上以下标i~j的区间涂成目标色的最少涂色次数
    - 状态转移方程：抓住重要特征，<u>首尾目标涂色相同时，可以一次涂完</u>
        - 当a[i] == a[j]时：**dp[i] [j] = min(dp[i+1] [j], dp[i] [j-1])**
        - 当a[i] != a[j]时：**dp[i] [j] = min(dp[i] [j], ==dp[i] [k] + dp[k+1] [j]==)**
    - 初始化状态数组：
        - `memset(dp, 0x3f, sizeof(dp))`----初始化最大值，便于取min
        - `dp[i] [i] = 1`单位板长涂一次即可
    - 敲代码，自下而上。从小的区间区间开始，计算大的区间，最终完成整个板长区间的计算

    代码：

    - ```cpp
        #include <iostream>
        #include <algorithm>
        #include <string>
        #include <cstring>
        using namespace std;
        string str;
        int dp[55][55];
        int main()
        {
        	cin >> str;
        	memset(dp, 0x3f, sizeof(dp));
        	str = '0' + str;//1下标开始存
        	for (int i=1; i<=str.size()-1; i++) dp[i][i] = 1;
        	for (int len=2; len<str.size(); len++)
        	{
        		for (int i=1; i+len-1<str.size(); i++)
        		{
        			int j = i+len-1;
        			for (int k=i; k<j; k++)
        			{
        				if (str[i] == str[j])//从板长2开始枚举，首尾相同等价于涂板长为1
        					dp[i][j] = min(dp[i+1][j], dp[i][j-1]);//由下之上转移~
        				else
        					dp[i][j] = min(dp[i][j], dp[i][k]+dp[k+1][j]);
        			}
        		}
        	}
        	cout << dp[1][str.size()-1] << endl;
        	return 0;
        }
        ```

    感悟：

    - 最值问题：答案区间已知，二分？贪心？貌似都行不通时。可以考虑dp了
    - dp的思路没有？？
        - 由上至下，分析推导：貌似推不下去
        - 这时你就尝试**由下至上**推导吖。这么死板？找到dp的状态转移特性
            - 这题特性就是首尾涂色相同时，先涂首或尾可以一次带着涂掉尾或首，直接等价于涂<u>去首/去尾后的板子</u>



## 背包问题

1、背包问题可以描述为：

- 给定一组（各种各样的）物品，每种物品都有自己的**重量**和**价格**，在限定的总重量内（我们的**背包容量**），我们如何选择，才能使得物品的<u>总价格最高</u>。
- 问题的名称来源于如何选择最合适的物品放置于给定背包中。
- 常见的是 01背包和完全背包

2、背包问题的种类

- ![image-20250513212637698](D:\Node-typora\note-picture\image-20250513212637698.png)

### 01背包

1、01 背包问题：

- 有n种物品，**每种物品只有一个**。第i（i从1开始编号）件物品的重量为**w[i]**，价值为**v[i]**。有一个给定**容量为 m**的背包，问这个背包最多能装的最大价值是多少？

2、问题分析

- 因为每种物品只有1个，那么在最终装好的背包中，**每个物品的状态只有两种**：

    - 1.要么该物品<u>没有被装入</u>背包（即没有入选最优解中，最优解中有0个该物品）

    - 2.要么该物品<u>被装入</u>背包了（即入选最优解中，最优解中有1个该物品）。

        所以该类问题名字是01背包

- 状态(数组)`dp[i][j]`：

    - 假设将所有物品排一排。从**前`i`个物品**中*<u>任选若干物品(0~i个)</u>*，装入**容量为`j`**的背包中的<u>最大价值</u>

- 推导状态转移方程
    即计算出dp[i] [j]，**默认前置状态<u>例dp[i-1] [j-w[i]]</u>都是已经算出的**

    - 对于前i个物品中的**第i个物品**，只有两种状态：选/不选
        - **不选**：等价于背包只从前i-1个物品中任选，最高价值也是在容量为j的前提下，前i-1物品任选出的价值之和。
            即`dp[i][j] = dp[i-1][j]`
        - **选**：等价于背包容量为j时，选定了第i个物品，剩余容量j - w[i]的背包去前i-1个物品中任选，任选出物品价值之和 + 选定的第i个物品的价值 = 最大价值。
            即`dp[i][j] = dp[i-1][j-w[i]] + v[i])`
            - 注意不要越界，把背包弄坏了
    - 最终整合得到方程：<font color=red>dp[i] [j] = max(dp[i-1] [j],  dp[i-1] [j-w[i]] + v[i])</font>
    
- **初始状态（初始化状态数组）**：

    - 一个物品都不选：`dp[0][j] = 0`
    - 背包容量为0，一个都选不了：`dp[i][0] = 0`
    - **总结**：<font color=red>反正都是初始化为0，又是<u>求最大价值</u>，干脆直接将dp初始化全局0（尽可能小）</font>

- 代码模板：

    - ```cpp
        for (int i=1; i<=n; i++)
        {//枚举前i个物品
            for (int j=1; j<=m; j++)
            {//枚举容量
                if (j >= w[i]){//第i个物品可以考虑选装或不选
                    dp[i][j] = max(dp[i-1][j], d[i-1][j-w[i]] + v[i]);
                }//否则只能不选
                else dp[i][j] = dp[i-1][j];
            }
        }//模拟过程：43min
        ```

- 答案就是输出：dp[n] [m]：在前n个物品（所有）中任选，装入容量为m的背包，的最大价值

3、降维优化：空间复杂度O(n^2^) --> O(n)

- 通过对上述分析结果进行模拟：<img src="D:\Node-typora\note-picture\image-20250514114439612.png" alt="image-20250514114439612" style="zoom: 50%;" />

    - 发现**计算前i个**物品中任选（也就是第i行）计算最大价值时，**只用到了前置状态i-1**（第i-1行），<font color=red>其他行用不到，可以与**旧的**第i-1行比较更新为**新的**第i行</font>
    - 所以我们可以直接降维成`dp[j]`：<u>前i个</u>物品任选装入容量为`j`的背包的最大价值

- 得到降维后的状态数组：`dp[j]`

- 状态转移方程自然就是：<font color=red>**dp[j] = max(dp[j], dp[j-w[i]] + v[i])**</font>

- 初始化状态全为0，用于后续比较取max

- 降维后==代码模板==：

    - ```cpp
        for (int i=1; i<=n; i++)
        {//只能对空间优化，思路逻辑没变，仍要枚举从前i个物品中任选
            for (int j=m; j>=w[i]; j--)
            {//j>=w[i]防越界，倒着枚举！！！
                dp[j] = max(dp[j], d[j - w[i]] + v[i]);
            }
        }
        ```

        - 我们在比较第`i`个物品是否选装时，只用到`i-1`这个前置状态，所以需要对背包容量`j`从大到小，倒着枚举

            > 因为从小到大枚举j容量,dp[j-w[i]]已经计算出来而不是0，此时**dp[j-w[i]]** + v[i]就相当于<u>选了两/多次第i行/第i个物品</u>，但这是01背包问题，造成结果错误。
            > 所以需要倒着枚举，保证前置dp[j-w[i]] = 0，不对后置状态产生影响

        - `j>=w[i]`：还是对第i个物品是否选择作出判断。

            > 不过此时是确保第`i`个物品可以选。
            >
            > **选后价值**与**不选价值（dp[j]就是上一行i-1的最大价值）**进行比较更新

### 完全背包

1、完全背包问题：

- 给你 n 种物品，每种物品都具有两个属性（价值v[ i ]和重量w[ i ]），每种物品都有**无限多**个，将他们放入容量为m 的背包中（可以重复放入同一个物品），怎么放才能让背包的价值最大？
- 与 01背包的区别：完全背包是可以重复取同一种物品，01背包只能取一次或不取

2、问题分析

- 同01背包，每==种==物品要么选，要么不选，不同的是：可以选0~∞==个==
- 状态数组dp[i] [j]：在前i种物品，任选几种（每种又任选几个），装入容量为j的背包中的最大价值
- 状态转移方程：
    - 第i种物品（一个）不选：dp[i] [j] = dp[i-1] [j]
    - 选1~k个：dp[i] [j] = dp[i-1] [j - w[i] * k] + k * v[i]，其中`k*w[i] <= j`, `k >= 1`
    - 整合：<font color=red>**dp[i] [j] = max(dp[i-1] [j],  dp[i] [j - k * w[i]] + k * v[i])**</font>
- 初始化为0
- 这样转移方程，需要再枚举k，这样时间复杂度就来到了恐怖的O(n^3^)

3、降维优化---时间+空间复杂度

- 前置：在之前对01背包的状态数组降维处理时，需要对背包容量**倒着枚举，避免一种物品多次选装**

    - 但处理完全背包时，这个特点就可以加以利用。

        > 利用这个特点就避免再多枚举一个k变量，将时间复杂度降了下来

    - 01背包一种物品只有一个，不可以多次选装，但完全背包就可以多次选装

- 得到降维后的状态`dp[j]`，状态转移方程：<font color=red>**dp[j] = max(dp[j], dp[j-w[i]] + v[i])**</font>

    - 同01背包，枚举背包容量可以直接正着枚举，保证可选、不越界

- ==代码模板==：

    - ```cpp
        for (int i=1; i<=n; i++)
        {
            for (int j=w[i]; j<=m; j++)
            {//正着枚举背包容量：保证能放1个（就不从0开始了，反正都初始化为0了）
                dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
            }
        }
        ```

4、01背包和完全背包的板子题

1. [P1048 NOIP 2005 普及组\] 采药 - 洛谷](https://www.luogu.com.cn/problem/P1048)

2. [P1616 疯狂的采药 - 洛谷](https://www.luogu.com.cn/problem/P1616)

    分析：

    - 记得开`long long`、条件：1≤*m*×*t*≤10^7^保证了O(n^2^)不会超时
    - `long long dp[10000005];`开这么大，本地能跑就是能跑



## 状压DP

1、状态压缩动态规划，俗称状压dp。

- 利用**计算机二进制**的性质来描述**状态**的一种DP方式
    > 之前使用状态数组。包括之前用0、1标记某某状态就是利用了二进制来描述状态，只是当时就这样理所当然地用了，没有往二进制上想
    
- 用二进制描述状态，但二进制不好存，所以转用十进制来存，但对十进制**用二进制的形式理解**
    - ![image-20250514211501568](D:\Node-typora\note-picture\image-20250514211501568.png)
    - eg：描述抛掷8个硬币的结果（0~255存储），00010010：18
        - 状压前：数组int coin[i] [j]：**i * j * 4B**
        - 状压后： 二进制描述十进制存储int coin：**4B**----大大节省空间
    
- 缺点：每一位两进制数只有两种状态，所以只能用于描述只有两种状态的单个事件
    - 所以如果单个事件有多个状态，如3个状态咋办？用3进制描述十进制存储呗~

状态压缩名字由来：

- <font color=red>使用二进制数表示状态**压缩小了数据存储空间**，还能利用二进制数的**位运算**很方便地进行**状态转移**</font>

2、剖析状压dp

- 状压DP其实是一种**暴力**的算法，因为它<u>需要遍历每个状态</u>，而每个状态是多个事件的集合，也就是以集合为状态，一个集合就是一个状态。

    - 解决的一般是**指数复杂度**的问题，所以状态压缩DP的复杂度是指数的，只能用于小规模问题的求解。

        > eg：描述抛硬币：32个硬币事件组成的集合为一个状态，共有2^32^种状态，用十进制存0~2^32^-1，这个其实就是int类型的最大值了，再多int都描述不完

- 重点：位运算---用于状态转移

3、位运算

- `&`：按位与，有0则0
- `|`：按位或，有1则1
- `^`：异或，相异则1
- `~`：按位取反，倒反天罡
- `<<`、`>>`：左右移，乘/除2的移动位数的次方
- **规律(原理)**：当某数x=1或0时
    - `1 & x = x`,**`0 & x = 0`**;
    - **`1 | x = 1`**, `0 | x = x`;

4、状压dp中常用的位运算技巧

1. 判断一个数字x二进制下的**第i位是不是等于1**。（最低第1位，从右往左数）

    - `if ((1 << (i-1)) & x)`：结果大于1则是，为0则不是

        原理：将1左移i-1位，<u>制造一个只有第i位上是1，其他位上都是0的二进制数</u>，让它按位与x

2. 将一个数字x二进制下**第i位更改成1**

    - `x = x | (1 << (i-1))`：

3. 将一个数字x二进制下**第i位更改成0**

    - `x = x & ~(1 << (i-1))`：

4. 将一个数字x二进制下**<u>最靠右的第一个1</u>去掉**

    - `x = x & (x-1)`：妙啊妙啊~~

5. | 技巧               | 实例             | 代码实现       |
    | ------------------ | ---------------- | -------------- |
    | 去掉最后一位       | 101101-->10110   | x >> 1         |
    | 在最后加一个0      | 101101-->1011010 | x << 1         |
    | 在最后**加一个1**  | 101101-->1011011 | x << 1 **+ 1** |
    | 把最后一位变成1    |                  |                |
    | 把最后一位变成0    |                  |                |
    | 最后一位取反       |                  |                |
    | 右数第i位取反      |                  |                |
    | 取末k位            |                  |                |
    | 取右数第i位        |                  |                |
    | 把末k位变成1       |                  |                |
    | 末k位取反          |                  |                |
    | 把右数第一个0变成1 |                  |                |
    | 把右数第一个1变成0 |                  |                |
    | 把右边连续的0变成1 |                  |                |
    | 把右边连续的1变成0 |                  |                |
    | 取右边连续的1      |                  |                |

- **优先级**：`~`、 `*` `/` `+` `-`、 `<<` `>>`、 `>` `<` `=`、`&`、`^`、`|`

5、状压dp应用条件

- 从问题类型一般分为：**棋盘类**问题（连通性问题）、**集合类**（类似01背包）问题

1. 解法需要保存一定的状态数据（表示一种状态的一个数据值（十进制）），每个状态数据通常情况下是可以通过2**进制**来表示的。这就要求状态数据的每个单元<u>只有两种状态</u>，
   
    > 比如说棋盘上的格子，放棋子或者不放，或者是硬币的正反两面。这样用0或者1来表示状态数据的每个单元，而整个状态数据就是一个一串0和1组成的二进制数
2. 解法需要将**状态数据**实现为一个**基本数据类型**，比如int，long等等，即所谓的状态压缩。
    - 状态压缩的目的一方面是缩小了数据存储的空间
    - 另一方面是在状态对比和状态整体处理时能够提高效率。
    
        > 这样就要求状态数据中的单元个数**不能太大**，比如用int来表示一个状态的时候，状态的单元个数不能超过64（64位的机器），所以题目一般都是至少有一维的数据范围很小。

6、例题

1. [P1896 SCOI2005\] 互不侵犯 - 洛谷](https://www.luogu.com.cn/problem/P1896)

    分析：

    - 第一眼国王？八皇后？dfs？枚举每一个国王的位置？好家伙O((n*n)!)铁超时。想新方法把

    - 对最终棋盘情况分析：每个格子只有两种状态，有或没有国王，所以可以用二进制位描述

        - <u>**每一行**看作一个大状态</u>，为一个二进制数。所以n*n棋盘，可以用n个二进制数表示

            - 将每一行的状态压缩成一个十进制数：0~（2^n^-1）

                > 所以最多有512种状态，则整个棋盘最多有**512^9^**种状态---其中会有<u>不合法的状态</u>，需要删去

            - 不合法情况：行内不合法、行间不合法

    - 按套路设**状态数组**为`dp[i][j][s]`：

        - 表示：我们已经选到了第 *i* 行（1~n行），第 *i* 行的**状态**为 *S*，用了 *j* 个国王的方案数

            > 这里的状态S是个十进制数，描述的是第i行棋盘状态，而不是整体状态

    - 状态转移方程: <font color=red>dp[i] [j] [s1] = **sum(**dp[i-1] [j - king_cnt[i]] [s2],  枚举合法的**)** </font>

        > **首先保证行内合法，<u>上一行向下一行转移</u>保证行间合法**

        - 行间冲突：<img src="D:\Node-typora\note-picture\image-20250516171332969.png" alt="image-20250516171332969" style="zoom: 33%;" />

            1. 正下方：`s1 & s2 == 0`才**不存在**正下冲突，`s1 & s2 > 0`则**冲突不合法**
            2. 左下方：`s1 & (s2>>1) == 0`
            3. 右下方：`s1 & (s2<<1) == 0`

            **总**：i-1行的状态s1转移到i行的状态s2，s2需满足条件：
            `(s1&s2 == 0) && (s1&(s2<<1) == 0) && (s1&(s2>>1) == 0)`

            可以简化：**(s2 | (s2>>1) | (s2<<1) ) & s1 == 0**

            >`|`按位或：有1则1，将可以将s1正下、左、右的s2的二进制位**可能的1**一并对齐，然后按位与&。这s2的三个二进制位有一处是1，就会与s1的1对齐

        - 行内冲突：一个国王的左、右格子不能再放其他国王

            1. 判断左边有没有国王：`s2 & (s2>>1) == 0`合法，没有国王

                >eg:  s2: 1 **1** 0 0 1
                >
                >​       s2:  0 1 **1 **0 0 将状态s2自身右移一位，与原状态对齐按位与
                >
                >得到`s2 & (s2<<1) != 0`，显然**加粗国王1**的左边是有国王的，此状态行内不合法

            2. 判断右边有没有国王：`s2 & (s2<<1) == 0`

            **总：**状态s2保证行内合法需满足：`(s2 & (s2<<1) == 0 ) && (s2 & (s2<<1) == 0)`

            简化：**( (s2<<1) | (s2>>1) ) & s2 == 0**

        - 综上：

            - 行间：<font color=red>**(s2 | (s2>>1) | (s2<<1) ) & s1 == 0**</font>
            - 行内：<font color=red>**( (s2<<1) | (s2>>1) ) & s2 == 0**</font>

        - 解题：

            - 每一行的状态数是固定的，最多有2^n^种，先对每一行进行预处理，得到<u>1.满足行内合法的状态</u>，再去<u>2.判断行间是否合法</u>

    思路：

    - **每一行的（行内合法）状态都是固定的**，有2^n^种，对其进行预处理，找到没有行内冲突的合法状态，记录下来为`legal[i]`
        - legal[i] = s状态，为一个十进制数
    - 再对每一个合法状态，计算国王数（转二进制有多少1），记录数组`k_cnt[s]`，表示`当前状态s`所放国王数
    - 状态数组**dp[i] [j] [s]**：我们已经选到了第 *i* 行（1~n行），第 *i* 行的**状态**为 *S*，用了 *j* 个国王的方案数
    - 状态转移方程：**dp[i] [j] [s1] += dp[i-1] [j - k_cnt[i]] [s2]**

累了吖：

- 啥玩意这是？







## 树型DP

1、树形DP准确的说是一种DP的思想。

- 将DP建立在树状结构的基础上。整体的思路大致就是用**树形的结构存储数据**，然后在**树上进行状态转移。**



## 数位DP

1、数位DP概述

- **数位**就是把一个十进制数，按照个位，十位，百位等等一位位的拆开，关注每一位上的数字。

数位 DP 一般有以下特征：

1. 要求的是<u>满足一定条件下的数</u>的数量，也就是说，最终的目标是统计数量。
2. 题目中会提供一个区间，作为统计的范围。
3. 区间的范围很大，不能普通枚举。

数位 DP 的原理很简单。

- 我们不再通过普通的加一来进行判断，而是将一些状态存储在数组里，然后直接枚举某一位的值，并且进行统计。这样，复杂度从原本的 O*(*n) 就变成了 *O*(log10(*n*)×10)。



2、





3、例题：

1. [P8764 蓝桥杯 2021 国 BC\] 二进制问题 - 洛谷](https://www.luogu.com.cn/problem/P8764)

    分析：数位dp

    - 设计状态：

        - ~~1.大佬版：~~设计状态dp[i] [j] [t]：前i位数，含有j个1，t表示0/1是否触顶

        - 2.萌新版：**dp[i] [j] [t]**：一个i位数，含有j个1，其中i位数的首位为t(= 0/1)

    - 初始化：

        - dp[1] [1] [1] = 1：一位数首位是1，含一个1的数就是1，只有一个
        - dp[1] [0] [0] = 1：一位数首位是0，含零个1的数就是0，只有一个

    - 转移方程：

        - **dp[i] [j] [1] = dp[i-1] [j-1] [1] + dp[i-1] [j-1] [0]**

            > 首位是1的i位数含j个1的数量 = [^8]新首位为`1`含`j-1`（被占用）个1的数量 + 新首位为`0`含`j-1`的1的数量
            >
            > - eg：解释为啥--暂略

        - **dp[i] [j] [0] = dp[i-1] [j] [1] + dp[i-1] [j] [0]**

            > 首位为0，没有占用1，新首位的i-1位数仍然含有`j`个1

    思路及步骤：

    - 将n转二进制存进另一个数组（不是dp数组）。下标1存最后一位，倒着存

        > <img src="D:\Node-typora\note-picture\image-20250606161908027.png" alt="image-20250606161908027" style="zoom: 50%;" />

    - 1.先对所有数进行初始化，也就是预处理出所有dp值
        	-----**使用由小到大++递推，覆盖最大数据范围的dp**

    - 答案：<font color=red>要确保枚举出来的数小于n(数位dp在枚举时需要满足的条件)</font>

        - 2.部分答案：假设输入的n的长度为len

            - ==ans = Σ dp[len - 1] [k] [1]==

                > 长度为len-1的数所有数位随便枚举1/0一定小于n
                >
                > len-1的数首位一定是1哈，不让就退化成len-2的数了

        - 3.另一部分答案：当枚举长度i == len，这时就该i位数就不一定小于n了

            -  <font color=red>因为i == len，所以首位一定也是1，不然会**退化**</font>

            -  去枚举剩下的位数`i,` 看看是否与n对齐----   `i`∈ `从len-1枚举到1`

                - n的该位 = 0，直接跳过，因为枚举的位数上也只能填0

                - n的该位 = 1

                    - ==ans += dp[i] [k - x] [0]==

                        > 枚举的位数上填0，后面无论怎么枚举，一定满足小于n
                        >
                        > x：表示前面遇到的1的个数，后面只剩下k-x的1可以用

                    - 枚举的位数上填1，继续看下一位，填1后x++

                - x初始化为1，因为第len位数是1

    - 输出答案ans（两部分整合）

    代码：

    - ```cpp
        #include <bits/stdc++.h>
        #define ll long long
        using namespace std;
        
        ll dp[70][70][2];//1e18 < 70二进制位 
        ll n, k; 
        ll bit[70];//都是从1开始存 
        int main()
        {
        	cin >> n >> k;
        	int len = 1;
        	while (n>0)
        	{
        		bit[len++] = n%2;
        		n /= 2;
        	}
        	len--;//真实二进制位数 
        	//初始化
        	dp[1][1][1] = 1;
        	dp[1][0][0] = 1;
        	//预处理
        	for (int i=2; i<=68; i++) {
        		for (int j=0; j<=68; j++){
        			if (i>=j){
        				dp[i][j][0] = dp[i-1][j][0] + dp[i-1][j][1];
        				dp[i][j][1] = dp[i-1][j-1][0] + dp[i-1][j-1][1];
        			}
        		}
        	}
        	//枚举比对n的二进制数组bit
        	ll ans = 0;
        	//第一部分答案，所有长度小于len的数 
        	for (int i=k; i<=len-1; i++) ans += dp[i][k][1];//首位一定为1，不然会退化 
        	//第二部分答案，长度等于len的数 
        	int x = 1; //从后往前第i位的前面位数中用了的1的个数 
        	for (int i = len-1; i>=1; i--)
        	{//从len-1位倒着枚举，保证枚举出来的数小于等于n 
        		if (x > k)
        		break;//等于k不可以跳过哈，第i位还可以枚举0啊 
        		if (bit[i] == 0) continue;
        		//第i位枚举0，后面位数随便枚举一定能小于n 
        		ans += dp[i][k-x][0];
        		//枚举1，继续看下一位
        		x++;
        	}
        	cout << ans << endl;
        	return 0;
        }
        ```

    感悟：

    - 动态规划的支配
    - 由浅入深的理解





























# 线段树

1、引入：

- 一颗由线段组成的二叉树（本质），即存储的不是一般的节点，而是区间
- 分治（**二分**）与二叉树的结合体：eg：<img src="D:\Node-typora\note-picture\image-20250517173719152.png" alt="image-20250517173719152" style="zoom:33%;" />
- 线段树是一种**二叉搜索树**

2、线段树的特性

1. 用分治法自顶向下建立，每次分治，左右子树各一半

    > 这里采用的就是二分，所以线段树本质是二叉树，而不是三叉四叉…

2. 每个节点都表示一个“线段”区间

    - **非叶子节点**包含多个元素
    - **叶子节点**只包含一个元素

3. 除了最后一层，其他层都是**满的**。----->近似完全二叉树，可以用数组存树。

    - 用一个数组tree[]存储节点（），构造完全二叉树，顺序存储。
    - 利用二叉树的性质5：若一个节点的存储下标为`k` ，则其左子节点的下标为`2k` ，其右子节点的下标为`2k +1`。

4. `l=r`，说明这是一个叶子节点。

5. `l<r`，说明他有两个子节点，左儿子`[l,m]`,右儿子`[m+1,r]`，其中`m=(l+r)/2`;

3、线段树的高效

- 每个结点的值，代表了以它为根的子树上所有节点的值，那么，查询这个子树所代表的区间的值时，就不必遍历整棵树，而是直接读取这棵子树的根值就行了。

    > 并且树形结构的操作时间复杂度是O(logn)

- **线段树最适合解决的问题的特征是**：大区间的解可以从小区间的解<u>合并</u>而来

- 线段树是算法竞赛中常用的用来<font color=red>维护区间信息</font>的数据结构

- 线段树可以在 O(log N) 的时间复杂度内实现:

    - 单点修改、区间修改
    - 区间查询（区间求和，求区间最大值，求区间最小值）等操作

- <font color=red>线段树保存左右区间l、r的同时，可以根据题目要求保存相应的值</font>

    > eg：要求区间和（其他最大、小值等操作同理），就在节点上在保存区间和。只需要在**递归**建树到叶子节点然后**回溯**操作
    >
    > - 两个子节点的和求和就是其根节点区间的和
    > - 叶子节点的和就是该单点（区间）的值

    - <img src="D:\Node-typora\note-picture\image-20250517175556867.png" alt="image-20250517175556867" style="zoom: 33%;" /><img src="D:\Node-typora\note-picture\image-20250517175631633.png" alt="image-20250517175631633" style="zoom: 50%;" />

4、上手线段树

- Q：每个节点存什么？如何存树？如何建树？

- A:

    1. 一个结点对应一段区间[l,r]，区间内有我们需要的值（区间和，最值等等），所以一个结点内要保存该结点对应区间的**左右边界l、r**和**需要的值sum、maxx、minn等**。

    2. 线段树近似完全二叉树，可以用**数组**存树。

        用一个数组tree[]存储节点。若一个节点的存储下标为`o` ，则其左子节点的下标为2 *o ，其右子节点的下标为2 *o +1

    3. 建树：以n个元素的区间(a[n])为基础建树。以维护区间和为例：

        - tree[]数组大小：开`4*n`保险，但可能会造成空间浪费

            > 1.当n = 2^k^，构建出来的线段树是深度为`k+1`的满二叉树，等比求和：共2^k+1^ = 2*n个节点
            >
            > 2.当n = 2^k^ + C，建树会多出一层，因为是数组存数，所以需要利用空节点构建深度为`k+2`的满二叉，所以共2^k+2^ = 4*n个节点

        - 基于**递归**建树。

            - 初始节点为1，因为你要从1号节点开始建树。
            - 左子树节点是o * 2，右子树节点是o*2+1。
            - 线段树在构造子树时，一个结点的两个子节点是平分这个子树的（特征中说过）在遍历时，左子树范围是[l,m],右子树是 [m+1,r],其中：m=(l+r)/2。

        - 线段树建树的时间复杂度为`O(n)`

        - 代码：

            ```cpp
            ```

            



# 字符串哈希



















# 注释

[^1]:在计数时，必须注意没有重复，没有遗漏。这种方法的基本思想是：**先不考虑重叠**的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时**重复计算的数目排斥出去**，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理
[^2]:nums[n]，其子区间共有1+2+…+n-1+n，即1/2·n^2^级
[^3]:写个减法substraction函数，这里的结果**保存在减数a数组里就行**，还要去除a数组中的前导0
[^4]:写一个check函数，判断二者的大小
[^5]:例如35*99（100-1），当两位数35乘以两位数99，当99==顶多==上100，35==顶多==上35==00==，==多两位数==，所以最多n+m位数
[^6]: 算术基本定理（唯一分解定理）：任何合数都表示为若干质数的乘积，且该分解因式是唯一的（不考虑顺序性）
[^7]:默认认为<u>类似dp[i-1] [j-1], dp[i-1] [j], dp[i] [j-1]这种前置状态</u>都是已知的。所以不要多想，就是自下往上推（不同于递归），假设就是已知的，**做好初始化，拿来用就行了**
[^8]: 剔除首位，得到一个i-1位数，它的新首位

